#### B
https://atcoder.jp/contests/abc404/tasks/abc404_b
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250506155110417-1449792479.png)
<details>
<summary>点击查看解题思路</summary>
解题思路
旋转操作的影响：每次旋转90度会改变网格的方向。旋转四次后会回到原始方向。因此，我们只需要考虑旋转0次、1次、2次或3次的情况。
计算差异：对于每种旋转次数（0到3次），计算当前旋转后的S与T之间的差异格子数（需要改变颜色的格子数），然后加上旋转次数（因为每次旋转也算一次操作）。
取最小值：在所有可能的旋转次数中，选择差异格子数加旋转次数的最小值。
代码
</details>

```cpp
#include<bits/stdc++.h>
using namespace std;
int cd(vector<string>S, vector<string>T){//两个vector(数组)函数
	int N = S.size();
	int ans = 0;
	for(int i=0;i<N;i++)for(int j=0;j<N;j++)if(S[i][j]!=T[i][j])ans++;
	return ans;
}
//翻转函数
vector<string> rro(vector<string>S){//返回类型为vector的vector函数
	int N = S.size();
	vector<string>ret(N, string(N,'.'));//初始化一个 N x N 的网格，所有元素默认为 '.'（后续会被覆盖）
	for(int i=0;i<N;i++)for(int j=0;j<N;j++)ret[i][j]=S[N-1-j][i];
	return ret;
}
signed main(){
	int n;
	cin >> n;
	vector<string> s(n), t(n);
	for(auto &x:s)cin >> x;
	for(auto &x:t)cin >> x;
	int ans = 1e9;
	for(int i=0;i<4;i++){
		ans = min(ans, cd(s,t)+i);//翻转次数+差值
		s = rro(s);
	}
	cout << ans << endl;
}
```
#### C
### 并查集

##### find 和 merge 操作使用路径压缩，近似 O(α(n))，其中 α 是反阿克曼函数，非常小。
###### 利用并查集检查连通图：
[C - Cycle Graph?](https://atcoder.jp/contests/abc404/tasks/abc404_c)

<details>
<summary>点击查看并查集</summary>

```
 int find(int x)					// 查找 x 的根节点
{
	while(pre[x] != x)			// 如果x的上级不是自己
		x = pre[x];				
	return x;					
}
路径压缩：
将x到根节点路径上的所有点的pre（上级）都设为根节点
int find(int x)     				// 查找结点 x 的根结点 
{
    if(pre[x] == x) return x;		// 递归出口：x 的上级为 x 本身，即 x 为根结点        
    return pre[x] = find(pre[x]);	// 此代码相当于先找到根结点 rootx，然后 pre[x]=rootx 
}
路径压缩算法之二（加权标记法）：
void union(int x,int y){
    x=find(x);							// 寻找 x 的代表元
    y=find(y);							// 寻找 y 的代表元
    if(x==y) return ;					// 如果 x和 y 的代表元一致，说明他们共属同一集合，则不需要合并，直接返回；否则，执行下面的逻辑
    if(rank[x]>rank[y]) pre[y]=x;		// 如果 x的高度大于 y，则令 y 的上级为 x
    else								// 否则
    {
        if(rank[x]==rank[y]) rank[y]++;	// 如果 x 的高度和 y 的高度相同，则令 y 的高度加1
        pre[x]=y;						// 让 x 的上级为 y
    }
}
这两个函数分别实现查找和合并功能
各动能代码汇总：
const int  N=1005					// 指定并查集所能包含元素的个数（由题意决定）
int pre[N];     					// 存储每个结点的前驱结点 
int rank[N];    					// 树的高度 
void init(int n)     				// 初始化函数，对录入的 n 个结点进行初始化 
{
    for(int i = 0; i < n; i++){
        pre[i] = i;     			// 每个结点的上级都是自己 
        rank[i] = 1;    			// 每个结点构成的树的高度为 1 
    } 
}
int find(int x)     	 		    // 查找结点 x 的根结点 
{
    if(pre[x] == x) return x;  		// 递归出口：x 的上级为 x 本身，则 x 为根结点 
    return find(pre[x]); 			// 递归查找 
} 

 改进查找算法：完成路径压缩，将 x 的上级直接变为根结点，那么树的高度就会大大降低 
 
int find(int x) {
    if(pre[x] == x) return x;		// 递归出口：x 的上级为 x 本身，即 x 为根结点 
    return pre[x] = find(pre[x]);   // 此代码相当于先找到根结点 rootx，然后 pre[x]=rootx 
} 

bool isSame(int x, int y)      		// 判断两个结点是否连通 
{
    return find(x) == find(y);  	// 判断两个结点的根结点（即代表元）是否相同 
}

bool join(int x,int y)
{
    x = find(x);						// 寻找 x 的代表元
    y = find(y);						// 寻找 y 的代表元
    if(x == y) return false;			// 如果 x 和 y 的代表元一致，说明他们共属同一集合，则不需要合并，返回 false，表示合并失败；否则，执行下面的逻辑
    if(rank[x] > rank[y]) pre[y]=x;		// 如果 x 的高度大于 y，则令 y 的上级为 x
    else								// 否则
    {
        if(rank[x]==rank[y]) rank[y]++;	// 如果 x 的高度和 y 的高度相同，则令 y 的高度加1
        pre[x]=y;						// 让 x 的上级为 y
	}
	return true;						// 返回 true，表示合并成功
}
```
</details>

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
const int mxn=2e5+7;
int f[mxn],deg[mxn];
int find(int x){
	return f[x] == x? x: f[x] = find(f[x]);//寻找父节点
}
void merge(int x, int y){
	x = find(x);
	y = find(y);
	if(x == y) return;
	f[x] = y;
}
void solve(){
 int n, m, u, v;
 cin >> n >> m;
 for(int i=1; i<=n; ++i)f[i] = i;//初始化父节点为本身
 for(int i=1; i<=m; ++i){
   cin >> u >> v;
   merge(u, v);
   ++deg[u], ++deg[v];
 } 
 for(int i=1; i<=n; ++i){
	if(deg[i] != 2) {
		cout << "No" << endl;
		return;
	}
	if(find(i) != find(1)){
		cout << "No" << endl;
		return;
	}
 }
 cout << "Yes" << endl;
}
signed main(){
ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
int T=1;
//cin>>T;
while(T--) solve();
return 0;
}
```