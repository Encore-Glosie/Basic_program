# B
https://atcoder.jp/contests/abc403/tasks/abc403_b
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250516134648441-162612965.png)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+7;
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
   string T,U; 
   cin>>T>>U; //指针匹配
   for(int i=0;i<=T.size()-U.size();++i){//i代表起始位置，肯定要大于U.size()的,attention"="
           int f=1;
    for(int j=0;j<U.size();++j){//j代表偏移量可使T与U同步变化
        if(T[i+j]!='?'&&T[i+j]!=U[j]){
            f=0; break;
        }
     }
    if(f){cout<<"Yes\n"; return 0;}
}
   cout<<"No\n"; 
    }

```
# C
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250516143155133-1021487017.png)
方案1：使用unordered_map嵌套unordered_set
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+7;
bool h[N];  // h[x]表示用户x是否有所有权限
unordered_map<int, unordered_set<int>> mp;  // mp[x]保存用户x有权限的页面集合

int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int n,m,Q,q,x,y;
    cin>>n>>m>>Q;
    while(Q--){
        cin>>q;
        if(q==1){
            cin>>x>>y;
            mp[x].insert(y);  // 用户x添加页面y权限
        }else if(q==2){
            cin>>x;
            h[x]=1;  // 用户x获得所有权限
        }else{
            cin>>x>>y;
            if(h[x] || mp[x].count(y)) cout<<"Yes\n";
            else cout<<"No\n";
        }
    }
    return 0;
}
```
方案2：使用双哈希表优化
```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=2e5+7;
bool h[N];  // 全局权限//二维map比哈希能存
unordered_map<int, unordered_map<int, bool>> mp;//mp[x][y]表示用户x是否有页面y权限
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int n,m,Q,q,x,y;
    cin>>n>>m>>Q;
    while(Q--){
        cin>>q;
        if(q==1){
            cin>>x>>y;
            mp[x][y] = true;
        }else if(q==2){
            cin>>x;
            h[x]=1;
        }else{
            cin>>x>>y;
            cout<<(h[x]||mp[x][y]?"Yes\n":"No\n");
        }
    }
    return 0;
}
```
方案3：使用set的数组
```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
    int N, M, Q;
    cin >> N >> M >> Q;
    vector<set<int>> can_view(N);
    vector<bool> can_view_all(N, false);
    for (int i = 0; i < Q; ++i) {
        int t, x;
        cin >> t >> x;
        --x;
        if (t == 1) {
            int y;
            cin >> y;
            --y;
            can_view[x].insert(y);
        } else if (t == 2) {
            can_view_all[x] = true;
        } else {
            int y;
            cin >> y;
            --y;
            if (can_view_all[x] || can_view[x].count(y)) {
                cout << "Yes\n";
            } else {
                cout << "No\n";
            }
        }
    }
}
```
