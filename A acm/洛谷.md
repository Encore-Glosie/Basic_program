
# 1.[Doubles](https://www.luogu.com.cn/problem/AT_abc392_d "[ABC392D] Doubles")
```cpp
#include <bits/stdc++.h>
  using namespace std;
#define int long long
#define endl "\n"
#define dl long double
const int mxn=105, mxm=1e5+5;
dl vis[mxn][mxm],cnt[mxn],t,ans;
set<int> a[mxm];
signed main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	cin>>t;
	for(int i=1;i<=t;++i){
		cin>>cnt[i];
		for(int j=1;j<=cnt[i];++j){
			int n;
			cin>>n;
			a[i].insert(n);//插入 set 自动去重
			++vis[i][n];//统计当前数字的个数
		}
	}
	for(int i=1;i<=t;++i){
		for(int j=i+1;j<=t;++j){  
			dl tot=0;
			for(auto it=a[i].begin();it!=a[i].end();++it)tot+=vis[i][*it]*vis[j][*it];//第i，j 层
			tot=tot/(cnt[i]*cnt[j]);// 相同的/总的
			ans=max(ans,tot);
		}
	}
	cout<<fixed<<setprecision(15)<<ans<<endl;//精度写法 
	return 0;
	}
```
```cpp
```
# 2.[Swap to Gather](https://www.luogu.com.cn/problem/AT_abc393_d "[ABC393D] Swap to Gather")
[货仓选址（贪心 中位数）详解_选仓库规范求解-CSDN博客](https://blog.csdn.net/weixin_52797843/article/details/122069259)

```cpp
//法1：移动0
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
//const int N = 5e5 + 9;
void solve(){
    int m;cin >> m;
    string s;cin >> s;
    int n = 0, cnt = 0, ans = 0;
    for(const auto &i : s) if(i == '1') ++n;   
    for(const auto &i : s) { //将0全部移动到1的左边或右边
        if(i == '1') ++cnt;
        else ans += min(cnt, n - cnt);//0每次移动的次数对应着移动方向上1的个数
    }   //对于每个0选择向左移还是向右移
    cout << ans << endl;
}
signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    solve();
    return 0;
}
法二：移动1（仓库选址问题，找中位数）
代码1
#include<bits/stdc++.h>
#define ll long long
using namespace std;

ll n,one[1000001];//"1" 的位置 
ll cnt; //0~k-1中1的个数 
ll x;//仓库的位置 
ll ans;
string a;
int main()
{
	cin>>n>>a;
	for(int i=0;i<n;i++)
	{
		if(a[i]=='1') one[cnt+1]=i-cnt,cnt++;//两个1之间的距离，即0的个数
	}
	x=one[(cnt+1)/2];//仓库选址，取中位数，1一定是优于0的，所以在1的位置中选中位数 
	for(int i=1;i<=cnt;i++) ans+=abs(one[i]-x);//算k~x 中0的个数，因为x是中位数，一定存在比它大的1的位置，故需要取绝对值 
	cout<<ans;
}
代码2
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
#define pii pair<int, int>
#define arr3 array<int, 3>
#define lowbit(x) (x) & (-x)
const int N = 2e5 + 10, M = 1e6 + 10, inf = 0x3f3f3f3f, Inf = INT_MAX, mod
= 1e9 + 7;
int n, ans, sz;
string s;
vi b;
/*
- 假设，这⼀堆连续的 1，最终位于 [l, l+M-1] 这⼀段（其中 M 是 1 的总数）。
- 那么我们应该把最左侧的 1 移动⾄ l 处，第⼆靠左的 1 移动⾄ l+1 处... 以此类推
- 总代价即为：sum(i) |a_i - (l+i-1)| （a_i 是第 i 个 1 的原本位置）
- 上式变形为 |(a_i-i) - (l-1)|，假设 b_i = a_i-i，x = l-1，那么上式即为 sum(i)
|b_i - x|
- 这是⼀个经典问题：在数轴上有若⼲个点，坐标分别为 b_1 ... b_n，请找出⼀个点 x，使其
到所有点的距离之和最⼩
- 这个点 x 应该位于所有 b 的中位数处。证明可以使⽤调整法的思想。
- 因此，在求出所有 b 的值之后，我们就知道了 x 的值，进⽽知道 sum(i) |b_i - x|，即为
答案
*/
void solve(){
cin >> n >> s;
int cnt = 1;
for(int i = 0; i < n; i++){
if(s[i] == '1') b.push_back(i - cnt), cnt++;
}
sort(b.begin(), b.end());
int mid = b[b.size() >> 1];
for(auto tmp : b)
ans += abs(tmp - mid);
cout << ans << endl;
}
signed main(){
ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
int T = 1;
//cin >> T;
while(T--) solve();
return 0;

}
```
```cpp
```
# 3.[Squares in Circle](https://www.luogu.com.cn/problem/AT_abc389_d "[ABC389D] Squares in Circle")
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
//#define ll long long
int r,ans;
double x,y;
signed main(){
cin>>r; 
for(int i=-r;i<r;++i){ 
if(i==0)continue;
 x=i+0.5; 
y=sqrtl(r*r-x*x)+0.5;
ans+=2*(floor(y))-1; 
}
	cout<<ans<<endl;
	return 0;
 }
```
```cpp
```
# 4.[Coming of Age Celebration](https://www.luogu.com.cn/problem/AT_abc388_d "[ABC388D] Coming of Age Celebration")
[差分][问题 - ZJHUOJ](http://172.20.8.83/problemset.php?search=%E5%B7%AE%E5%88%86)
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define endl "\n"
//#define ll long long
const int mxn=5e5+7;
int a[mxn],b[mxn],n;
signed main(){
	cin>>n;     
	for(int i=1;i<=n;++i) cin>>a[i],b[i]=a[i]-a[i-1];//构造差分数组
	for(int i=1;i<=n;++i){
		a[i]=b[i]+a[i-1];//当前拥有的石头
		int ans=a[i]-n+i;//减去给后面的人的石头
		++b[i+1];//差分，后面会加上
		if(ans<0){
			--b[i+a[i]+1];//最多能给到哪里，给不到的还原
			cout<<0;
		}
		else cout<<ans;
    cout<<(i==n?"\n":" ");
	}
	return 0;
}
```
```cpp
```
# 5.[Kaiten Sushi](https://www.luogu.com.cn/problem/AT_abc382_c "[ABC382C] Kaiten Sushi")
```cpp
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define endl "\n"
//#define ll long long
const int mxn=2e5+5;
int a[mxn],c[mxn],b, n, m, x, f=-1;
void solve(){ 
  cin >> n >> m;
  memset(c,0x3f,sizeof c);
  for(int i = 1; i <= n; ++ i) cin >> a[i], c[i] = min(c[i-1], a[i]);//升序的那个人永远都吃不到//找前缀最小，顺便降序排序
  for(int i = 1; i <= m; ++ i){
    cin >> b;  //二分 第一个<=                                               
    auto it = lower_bound(c + 1, c + n + 1, b, greater<int>())-c;//it 迭代器返回类似地址指针，找不到返回end();
    cout << (it > n? f : it) << "\n";
  }
  return;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int T=1;
  //cin << T;
  while(T--) solve();
	return 0;
}
```
```cpp
```
## [P10425 [蓝桥杯 2024 省 B] R 格式 - 洛谷](https://www.luogu.com.cn/problem/P10425)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int MAX=1e5+1;
int n,a[MAX],len;//定义
string q;//因为数据太大，用string存储
void times(){//高精乘法
    for(int i=1;i<=len;i++)a[i]*=2; //按位乘2
    for(int i=1;i<=len;i++){//处理进位
        a[i+1]+=a[i]/10;
        a[i]%=10;
    }
    if(a[len+1])len++;//如果最高位的前一位进位后不是0就要增加长度
}
int main(){
    cin>>n>>q;//输入
    reverse(q.begin(),q.end());//反转q（方便后续）
    int p=q.find(".");//p用来分割整数、小数部分
    q.erase(p,1);//把小数点删了
    len=q.size();//小数总长
    for(int i=0;i<len;i++)a[i+1]=q[i]-'0';//字符串转整数数组
    for(int i=1;i<=n;i++)times();//n次乘2
    if(a[p]>=5)a[p+1]++;//小数部分第一位为5四舍五入进位
    for(int i=p+1;i<=len;i++){//检查进位
        a[i+1]+=a[i]/10;
        a[i]%=10;
    }
    if(a[len+1])len++;//再次检查最高位
    for(int i=len;i>p;i--)cout<<a[i];//因为前面逆序了,所以这里倒着输出
    return 0;//完美结束

}
```
```cpp
```
# 6.[E - Flip Edge]([E - Flip Edge](https://atcoder.jp/contests/abc395/tasks/abc395_e))
```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define pii pair<int,int>//将两个数据合并成一个定义的对象
const int mxn=1e6+7;
int n,m,k,h[mxn],w[mxn],e[mxn],ne[mxn],idx,dist[mxn];
bool st[mxn];
void add(int a,int b,int c){//起点，终点，权重
    w[idx]=c;//权重
    e[idx]=b;//终点
    ne[idx]=h[a];//next side
    h[a]=idx++;//now point to next side
    return;
}

void dijkstra(){
    memset(dist,0x3f,sizeof dist);//初始化距离为无穷大
    dist[1]=0;
    priority_queue<pii,vector<pii>,greater<pii>>heap;//now dist and next w[side]
    heap.push({0,1});
    while(!heap.empty()){
        pii cur=heap.top();//heap 里面的对象也是成对存在的，所有可以赋值
        int distance=cur.first;
             int ver=cur.second;
             heap.pop();
        if(st[ver])continue;//have visited;
        st[ver]=1;
        for(int i=h[ver];i!=-1;i=ne[i]){//now to next
            int j=e[i];//end point;
            if(dist[j]>distance+w[i]){//原来到达下一条边的值比现在要到下一条边（=当前点+权重）大，则更新为当前的方案
                dist[j]=distance+w[i];
                heap.push({dist[j],j});//当前值和下一个点
            }
        }
    }
    cout<<min(dist[n],dist[n<<1])<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin>>n>>m>>k;
    memset(h,-1,sizeof h);
    for(int i=1;i<=n;++i)
    add(i,i+n,k),add(i+n,i,k);//注意+n相当于另起一层；只有反转也就是链接路径需要花费，这个操作之后需要再花费1走这条路
    while(m--){
        int a,b;
        cin>>a>>b;
        add(a,b,1);//原图正向边
        add(b+n,a+n,1);//复制图反向边//通过反转操作到达对应的镜像位置，然后跟上面的路一样继续走//反转与走是独立的两个操作
    }
    dijkstra();
    return 0;
}
```
# 7.[Palindromic Shortest Path ](https://www.luogu.com.cn/problem/AT_abc394_e)
```cpp
代码 1 秒大概可以运算 1e8 次
```
![[Pasted image 20250330201557.png]]
 ```cpp
 //正难则反，由（i，j）汇集到一个顶点的两条路径边的情况(相同则是回文)
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define endl "\n"
//#define ll long long
const int mxn = 1e2 + 5, INF = 0x3f3f3f3f;
int n, ans[mxn][mxn], q[mxn * mxn][2];//手写队列
char s[mxn][mxn];
void solve() {
	cin >> n;
	int hd = 1, tl = 0;
	memset(ans, INF, sizeof ans);
	for (int i = 1; i <= n; ++i)cin >> s[i] + 1;
	for (int i = 1; i <= n; ++i) {
		ans[i][i] = 0;
		q[++tl][0] = i; q[tl][1] = i;
		//(i,i):0 入队
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			if (i != j && s[i][j] != '-') {
				ans[i][j] = 1;
				q[++tl][0] = i; q[tl][1] = j;
				//(i,j):1 入队
			}
		}
	}
	//bfs()
	while (hd <= tl) {
		int u = q[hd][0], v = q[hd][1];
		//取出状态（u，v)
		++hd;
		for (int i = 1; i <= n; ++i) if (s[i][u] != '-') {
			for (int j = 1; j <= n; ++j) if (s[v][j] == s[i][u]) {
				//扩展后的状态
				if (ans[i][j] == INF) {
					ans[i][j] = ans[u][v] + 2;
					q[++tl][0] = i; q[tl][1] = j;
				}
			}
		}
	}
	for (int i = 1; i <= n; ++i) {
		for (int j = 1; j <= n; ++j) {
			if (ans[i][j] == INF)cout << "-1";
			else cout << ans[i][j];
			cout << (j == n ? "\n" : " ");
		}
	}
	return;
}
signed main() {
	ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
	int T = 1;
	//cin << T;
	while (T--) solve();
	return 0;
}//time limit?! look more
代码二
#include<bits/stdc++.h>
#define N 105
using namespace std;
int n,ans[N][N];
string a[N];
queue<pair<int,int>> q;
signed main(){
	cin>>n;
	for(int i=1;i<=n;i++) cin>>a[i],a[i]=' '+a[i];
	memset(ans,-1,sizeof ans);
	for(int i=1;i<=n;i++) ans[i][i]=0,q.push({i,i});
	for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
		if(i!=j&&a[i][j]!='-') ans[i][j]=1,q.push({i,j});
	while(!q.empty()){
		auto [x,y]=q.front();//注意 该写法仅c++17或以上可用
		q.pop();
		for(int i=1;i<=n;i++) for(int j=1;j<=n;j++)
			if(ans[i][j]==-1&&a[i][x]==a[y][j]&&a[i][x]!='-')
				ans[i][j]=ans[x][y]+2,q.push({i,j});
	}
	for(int i=1;i<=n;i++){
		for(int j=1;j<=n;j++) cout<<ans[i][j]<<" ";
		cout<<"\n";
	}
	return 0;
}
```
 ```cpp
```
# 8.[Snaky Walk](https://www.luogu.com.cn/problem/AT_abc387_d)
```cpp
#include<bits/stdc++.h>
#define N 1010
using namespace std;
struct Sta{int x,y,ste;bool dir;};
int n,m,sx,sy,tx,ty,dx[4]{-1,0,1,0},dy[4]{0,1,0,-1};
//0要走上下，1要走左右 
string s[N];
queue<Sta> q;
bitset<N> vis[2][N];//比vis[2][N][N]占用空间小
signed main(){
	cin>>n>>m;
	for(int i=1;i<=n;i++) cin>>s[i],s[i]=' '+s[i];
	for(int i=1;i<=n;i++) for(int j=1;j<=m;j++){
		if(s[i][j]=='S') sx=i,sy=j;
		else if(s[i][j]=='G') tx=i,ty=j;
	}
	q.push({sx,sy,0,0}),q.push({sx,sy,0,1});
	while(!q.empty()){
		Sta t=q.front();
		bool dir=t.dir;
		int ste=t.ste,x=t.x,y=t.y;
		if(x==tx&&y==ty){
			cout<<ste<<"\n";
			return 0;
		}
		q.pop();
		if(vis[dir][x][y]) continue;
		vis[dir][x][y]=1;
		for(int i=dir;i<4;i+=2){
			int xx=x+dx[i],yy=y+dy[i];
			if(xx<1||yy<1||xx>n||yy>m||s[xx][yy]=='#') continue;
			q.push({xx,yy,ste+1,!dir});
		}
	}
	cout<<"-1\n";
	return 0;
}```
```cpp
```
#  9.[带分数](https://www.luogu.com.cn/problem/P8599)
```cpp
int num[] = { 1, 2, 3 };
do {
	cout << num[0] << " " << num[1] << " " << num[2] << endl;
} while (next_permutation(num, num + 3));
//next_permutation(begin,end)生成当前序列的下一个全排列，返回1，已达到最大全排列（即下一没有）则返回0；

代码
#include <bits/stdc++.h>
using namespace std;
//#define int long long
#define endl "\n"
//#define ll long long
int n, ans, u[12] = { 0,1,2,3,4,5,6,7,8,9 };
int makenum(int l, int r) {
int t = 0;
for (int i = l; i <= r; ++i) {
	t *= 10;
	t += u[i];
}
return t;
}
void solve() {
    cin >> n;
    do {
    for (int i = 1; i <= 7; ++i) {
    for (int j = i + 1; j <= 8; ++j) {
		int num1 = makenum(1, i);
		int num2 = makenum(i + 1, j);
		int num3 = makenum(j + 1, 9);//第三个数字(分子上的)最大让它到9
		if (num1 + (num2 / num3) == n && (num2 % num3 == 0))++ans;
		}//实质是找满足条件全排列三个数字
	}
} while (next_permutation(u + 1, u + 10));
cout << ans << endl;
return;
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int T = 1;
    //cin << T;
    while (T--) solve();
    return 0;
}
```
# 10.[选数异或]([P8773 [蓝桥杯 2022 省 A] 选数异或 - 洛谷](https://www.luogu.com.cn/problem/P8773))
```cpp
当数据过大无法用哈希表来储存时，可以用map;
Map的最大容量为2^30（约10亿）-> 1e9;
```
![[Pasted image 20250331184541.png]]

```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
//#define ll long long
const int mxn = 1e5 + 7;
int n, m, x, f[mxn], a, l, r;
map<int, int>las;
void solve() {
    cin >> n >> m >> x;
    for (int i = 1; i <= n; ++i) {
        cin >> a;
        f[i] = max(f[i - 1], las[a ^ x]);//维护，序列可能是无序的，las最后一个出现的位置,(可能会出现在前面，出先在前面就可以以f[i-1]为准)没有的话就是0；
        las[a] = i;//标记位置
    }
    while (m--) {
        cin >> l >> r;
        if (l <= f[r])cout << "yes" << endl;//由于更新，f[r]不会大于r
        else cout << "no" << endl;
    }
    return;
}
signed main() {
    ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);
    int T = 1;
    //cin << T;
    while (T--) solve();
    return 0;
}

```
# 11.[X 进制减法](https://www.luogu.com.cn/problem/P8782)
![[Pasted image 20250331202900.png]]
and正数加模再取模和直接取模的答案一样

![[Pasted image 20250331205643.png]]
```cpp
为了保证得到非负数模的模只需要在结果加模再取模就行
题中A>=B就是保证了结果为非负数

位权展开法的核心思想是：每一位上的数字乘以该位对应的位权，
再把所有结果相加，最终得到十进制数。对于不同位进制不同的数，
每一位的位权是该位之前所有位的进制的乘积。
for(int i=n,ans=0;i>=1;--i)//位权算法
  ans=ans*w[i]+x[i];
  cout<<ans<<endl;
  
#include <bits/stdc++.h>
using namespace std;
#define int long long
#define endl "\n"
//#define ll long long
const int mxn=1e5+7,mod=1e9+7;
int n1,m1,x1[mxn],n2,m2,x2[mxn],ans;
void solve(){//贪心 //n其实没啥用
  cin>>n1>>m1;
  for(int i=m1-1;i>=0;--i)cin>>x1[i];
   cin>>m2;
  for(int i=m2-1;i>=0;--i)cin>>x2[i];
  for(int i=max(m1,m2)-1;i>=0;--i)//位权算法
  ans=(ans*max(2LL,max(x1[i]+1,x2[i]+1))+x1[i]-x2[i]+mod)%mod;
  cout<<ans<<endl;
  return;
}
signed main(){
	ios::sync_with_stdio(0);cin.tie(0);cout.tie(0);
	int T=1;
  //cin << T;
  while(T--) solve();
	return 0;
}
```
# 12[统计子矩阵](https://www.luogu.com.cn/problem/P8783)
 ==尺取法==
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define int long long
#define ll long long
const int mxn = 5e2 + 7;
int n, m, k, a[mxn][mxn];
ll sum[mxn][mxn], ans;
void solve() {
    cin >> n >> m >> k;
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= m; ++j) {
            cin >> a[i][j];
            sum[i][j] += sum[i - 1][j] + a[i][j];//每一列的前缀和
        }
    }
    for (int up = 1; up <= n; ++up) {
        for (int down = up; down <= n; ++down) {
            ll h = 0;
            for (int l = 1, r = 1; r <= m; ++r) {
                h += sum[down][r] - sum[up - 1][r];
                while (h > k) {
                    h -= sum[down][l] - sum[up - 1][l];
                    ++l;
                }
                ans += r - l + 1;
            }
        }
    }
    cout << ans << endl;
    return;
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T;
    //cin>>T;
    T = 1;
    while (T--)solve();
    return 0;
}
```
# 13.[积木画](https://www.luogu.com.cn/problem/P8784)
```cpp
递推可以把结果都先列出来然找规律
分别取模再相加的结果也要再次取模
f[i][0] = ((f[i - 1][0] + f[i - 2][0]) % mod + (f[i - 1][1] + f[i - 1][2]) % mod) % mod
```
# 14.[冶炼金属](https://www.luogu.com.cn/problem/P9240)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
//#define ll long long
//const int mxn=1e4+5,mod=1e9+7;
int n,a,b,mxv=0x3f3f3f3f,mnv;
void solve(){
   cin>>n;
   for(int i=1;i<=n;++i){
    cin>>a>>b;
   mnv=max(mnv,a/(b+1)+1);// a/(b+1)+1正好能冶炼b+1个，v+1,正好不能冶炼b+1个得到最小效率v
   mxv=min(mxv,a/b);//满足所有能冶炼的最大效率的最小值
   }
   cout<<mnv<<" "<<mxv<<endl;
    return ;
}
signed main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int T;
  //cin>>T;
  T=1;
  while(T--)solve();
  return 0;
} 
```
# 15.[接龙数列](https://www.luogu.com.cn/problem/P9242)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
#define ll long long
const int mxn=1e5+7;
//int mod=1e9+7;
int n,dp[mxn],maxx;//以dp[i]结尾的最长接龙数列
string s;
void solve(){
    cin>>n;
    for(int i=1;i<=n;++i){
    cin>>s;
    int len=s.length();
    dp[s[len-1]-'0']=max(dp[s[len-1]-'0'],dp[s[0]-'0']+1);
    }//如果是连续的这个数字的个数就会不断递增和转化
     for(int i=0;i<=9;++i)maxx=max(maxx,dp[i]);
     cout<<n-maxx;
    return ;
}
signed main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int T;
  //cin>>T;
  T=1;
  while(T--)solve();
  return 0;
} 
```

# 16.[砍竹子](https://www.luogu.com.cn/problem/P8787)
```cpp
因为这题是求最小操作次数，而且每次操作都会变小，
所以肯定要优先操作大的元素，这样它变小之后才可能和其它元素一起操作以减少操作次数。
还能操作的次数最大，操作后**有可能和相邻的竹子能够一起砍**，一起砍肯定比分开砍操作次数小。
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define int long long
//#define ll long long
const int mxn = 2e5 + 7;
//int mod=1e9+7;
int n, high[mxn], times[mxn], maxt, ans;
inline int magic(int h) {
    return (int)floor(sqrt(floor(h / 2) + 1));//floor返回值是浮点型
}
void solve() {
    int n;
    cin >> n;
    for (int i = 1; i <= n; ++i) {
        cin >> high[i];
        int m = high[i];
        while (m != 1) {
            m = magic(m);
            ++times[i];
        }  //竹子的最大砍伐次数
        maxt = max(maxt, times[i]);
    }
    for (int i = maxt; i >= 1; --i) {
        for (int j = 1; j <= n; ++j) {
            if (i == times[j]) {
                if (high[j] != high[j + 1])++ans;//只有不同的才会++

                --times[j]; high[j] = magic(high[j]);
            }
        }
    }
    cout << ans << endl;
    return;
}
signed main() {
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T;
    //cin>>T;
    T = 1;
    while (T--)solve();
    return 0;
}
```
# 17.[树的直径](https://www.luogu.com.cn/problem/B4016)
```cpp
代码1
定理：在一棵没有负权树上，从任意节点y开始进行一次 DFS,到达的距离其最远的节点z必为直径的一端。
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define ll long long
//#define int long long
const int mxn=1e5+7;
int d[mxn],c;
vector<int>E[mxn];//邻接表
void dfs(int u,int fa){
  for(int v:E[u]){//遍历与节点u相邻的所有节点v。
  if(v==fa)continue;
  d[v]=d[u]+1;//更新节点v到起点的距离，因为v是u的子节点，所以v到起点的距离等于u到起点的距离加1。
  if(d[v]>d[c])c=v;//如果节点v到起点的距离大于当前记录的最远节点c到起点的距离，就更新c为v。
  dfs(v,u);//找到父节点u的最大距离,继续从节点v进行深度优先搜索,此时v的父节点为u。
  }
}
void solve(){
  int n,u,v;
  cin>>n;
  for(int i=1;i<n;++i){
    cin>>u>>v;
    E[u].push_back(v); E[v].push_back(u);//邻接表(双向路径)
  }
  dfs(1,0);//找到距离节点1(可以从任何节点开始)最远的节点 c
  d[c]=0; dfs(c,0);//从c重新开始找最远的
  cout<<d[c]<<endl;
  return ;
}
signed main(){
  int T=1;
 // cin>>T;
  while(T--)solve();
  return 0;
}
代码2
可以用于含有负权的树
这段代码里 dfs 函数的核心思路就是针对树里的每个节点，找出从该节点出发到两个不同方向的最远和次远叶子节点的距离，
把这两个距离相加，然后取所有节点对应的这个和的最大值，这个最大值就是树的直径。
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define ll long long
//#define int long long
const int mxn = 1e5 + 7;
int d1[mxn], d2[mxn], d, c;
vector<int>E[mxn];//邻接表
void dfs(int u, int fa) {
    d1[u] = d2[u] = 0;
    for (int v : E[u]) {//使用 auto 的好处是，若容器元素类型发生改变，代码无需手动修改循环变量的类型，编译器会自动推导，从而提高代码的可维护性与灵活性。
		if (v == fa)continue;
		dfs(v, u);//必须在这里递归//一条路走到底然后回溯
        int t = d1[v] + 1;//以下维护一个最大值，维护一个次大值
        if (t > d1[u])d2[u] = d1[u], d1[u] = t;//如果t大于当前记录的d1[u]，说明找到了一条更远的路径。此时，将原来的d1[u]值赋给d2[u]，并将d1[u] 更新为t。
        else if (t > d2[u])d2[u] = t;//如果 t不大于d1[u]但大于d2[u]，说明找到了一条次远的路径，将d2[u]更新为t。	    
    }
    d = max(d, d1[u] + d2[u]);
}
void solve() {
    int n, u, v;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        cin >> u >> v;
        E[u].push_back(v); E[v].push_back(u);//邻接表(双向路径)
    }
    dfs(1, 0);//找到距离节点1(可以从任何节点开始)最远的节点d;
    cout << d << endl;
    return;
}
signed main() {
    int T = 1;
    // cin>>T;
    while (T--)solve();
    return 0;
}
```
#### 例：
# 18.[大臣的旅费](https://www.luogu.com.cn/problem/P8602)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define int long long
const int mxn = 1e5+7;
int d[mxn], di;
vector<pair<int, int>> E[mxn];//邻接表
void dfs(int u, int fa) {//fa其实也是E[u]中的一个
    for (auto v : E[u]) {
        if (v.first == fa) continue;
        d[v.first] = d[u]+v.second;//父节点与子节点的距离；注意和代码2对比
        if (d[v.first]>d[di]) di = v.first;
        dfs(v.first, u);
    }
}
void solve() {
    int n, a, b, c;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        cin >> a >> b >> c;
        E[b].push_back({a, c});//所以E[u]中的u是对应的节点,而E[u]中包含了两个数
        E[a].push_back({b, c});
    }
    dfs(1, 0);//这是从任意点出发的问题，不要和最短路等搞混
    d[di] = 0;
    dfs(di, 0);
    cout << d[di]*10+(d[di]+1)*d[di]/2 << endl;
    return;
}

signed main() {
    int T = 1;
    //cin >> T;
    while (T--) solve();
    return 0;
}
代码2
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define int long long
const int mxn = 1e5+7;
int d1[mxn],d2[mxn],di;
vector<pair<int, int>> E[mxn];//邻接表
void dfs(int u, int fa) {
  d1[u]=d2[u]=0;
    for (auto v : E[u]) {
        if (v.first == fa) continue;
        dfs(v.first, u);//一条路走到底然后回溯
        int t = d1[v.first]+v.second;//注意v.first,因为是从子节点出发的
        if (t>d1[u]) d2[u]=d1[u],d1[u]=t;
        else if(t>d2[u])d2[u]=t;   
    }
    di=max(di,d1[u]+d2[u]);
}
void solve() {
    int n, a, b, c;
    cin >> n;
    for (int i = 1; i < n; ++i) {
        cin >> a >> b >> c;
        E[b].push_back({a, c});//所以E[u]中的u是对应的节点,而E[u]中包含了两个数
        E[a].push_back({b, c});
    }
    dfs(1, 0);
    cout << di*10+(di+1)*di/2 << endl;
    return;
}
signed main() {
    int T = 1;
    //cin >> T;
    while (T--) solve();
    return 0;
}```
## [地宫取宝](https://www.luogu.com.cn/problem/P8612)
```cpp
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long
const int mod=1e9+7;
ll dp[55][55][22][22];
int w[55][55],k,n,m,ans;//w一定要开得足够大
ll dfs(int x,int y,int maxx,int step){//开longlong重要!
  if(x>n||y>m)return 0; //记一下吧,在maxx初始值不能为0(为-1)的情况下,maxx+1可以防止出现负下标
  if(dp[x][y][maxx+1][step]!=-1)return dp[x][y][maxx+1][step];
  dp[x][y][maxx+1][step]=0;
  if(x==n&&y==m){
    if(step==k||(step==k-1&&maxx<w[x][y]))//最后一个宝贝的两种情况拿或不拿
    dp[x][y][maxx+1][step]=1;//找到了一条路径，会在后面的溯源中都加上
    }
  else{
    dp[x][y][maxx+1][step]+=dfs(x+1,y,maxx,step);
    if(w[x][y]>maxx)dp[x][y][maxx+1][step]+=dfs(x+1,y,w[x][y],step+1)%mod;
    dp[x][y][maxx+1][step]+=dfs(x,y+1,maxx,step);
    if(w[x][y]>maxx)dp[x][y][maxx+1][step]+=dfs(x,y+1,w[x][y],step+1)%mod;
  }
  return dp[x][y][maxx+1][step]%mod;
}
void solve() {
    cin>>n>>m>>k;
   for(int i=1;i<=n;++i)
    for(int j=1;j<=m;++j)
     cin>>w[i][j];
  memset(dp,-1,sizeof dp);//初始值要包括1，因为宝贝的价值是包括0的
  cout<<dfs(1,1,-1,0)<<endl;
  return;
}
signed main() {
    int T = 1;
    //cin >> T;
    while (T--) solve();
    return 0;
}
```
# 19.[八皇后 Checker Challenge - 洛谷](https://www.luogu.com.cn/problem/P1219)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
const int mxn=1e2+7;
int r[mxn],c[mxn],n,tot,d[mxn],b[mxn];
void dfs(int i){//第i行
   if(i>n){
   if(tot<=2){
    for(int k=1;k<=n;++k)cout<<r[k]<<" ";
    cout<<endl;
   }
    ++tot;
    return;
   }
   else{
    for(int j=1;j<=n;++j){//遍历列
    if(!c[j]&&!d[i+j]&&!b[i-j+n]){//i-j+n偏移量可以保证其值为正 即如果i1-j1==i2-j1,则i1-j1+n==i2-j2+n
       r[i]=j;      
       c[j]=1;
       d[i+j]=1;
       b[i-j+n]=1;
       dfs(i+1);//继续往下搜
        c[j]=0;//还原，为下一次搜索做准备//注意return 到那一层i也返回对应的那一层的值
       d[i+j]=0;
       b[i-j+n]=0;
    }
   }
   }
}
void solve(){
  cin>>n;
  dfs(1);
  cout<<tot<<endl;
  return ;
}
signed main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int T=1;
  //cin>>T;
  while(T--)solve();
  return 0;
}
```
# 20.[ 单词接龙 - 洛谷](https://www.luogu.com.cn/problem/P1019)
```cpp
可以利用string s[mnx],来定义字符串数组；
s[i].substr(j,k)截取从k到j的字符串；
s.size()返回unsigned int 无符号整型(正数)，与int作比较是会出现错误，
所以可以转化成 (int)s.size();再做运算

#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
const int mxn=1e2;
string s[mxn];
char c;
int n,maxx,vis[mxn];
void dfs(const string &tmp){//引用，tmp是一个字符串
    maxx=max(maxx,(int)tmp.size());
    for(int i=1;i<=n;++i){
      if(vis[i]==2)continue;//注意vis的初始值为1，等于2证明以这个字母开头的数被用过一次
      for(int j=1;j<min(tmp.size(),s[i].size());++j){//遍历到第一个和最后一个就行
        if(tmp.substr(tmp.size()-j)==s[i].substr(0,j)){
          ++vis[i];
          dfs(tmp+s[i].substr(j));
          --vis[i];
        }
      }
    }
  return;
}
void solve(){
  cin>>n;
  for(int i=1;i<=n;++i)cin>>s[i];
  cin>>c;
  for(int i=1;i<=n;++i)if(s[i][0]==c){
    ++vis[i];//相当于初始化为1了
    dfs(s[i]);
    ++vis[i]=0;
  }
  cout<<maxx<<endl;
    return ;
}
signed main(){
  ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
   int T=1;
  //cin>>T;
  while(T--)solve();
  return 0;
}
```
# 21.[洛谷图论大礼包](https://www.luogu.com.cn/training/14206#information)