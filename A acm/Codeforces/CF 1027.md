
# [Codeforces 1027 (Div. 3) - Codeforces](https://codeforces.com/contest/2114)
## [1027D](https://codeforces.com/contest/2114/problem/D)
###### 解析
*这段代码是用来解决一个关于在巨大网格中消灭所有怪物所需最少金币数的问题。以下是代码的逐步解析： 问题理解 网格大小：10^9 × 10^9的矩阵。 怪物位置：n个怪物分布在不同的单元格中，每个单元格最多一个怪物。 操作：最多可以移动一个怪物到任意未被占据的单元格一次。 目标：选择一个矩形，消灭其中的所有怪物。消耗的金币数等于矩形的面积（格子数）。任务是找到消灭所有怪物的最小金币数。 解题思路 关键观察：如果不移动任何怪物，最小金币数是包围所有怪物的最小矩形的面积（即(x_max - x_min + 1) × (y_max - y_min + 1)）。 移动一个怪物的影响：通过移动一个怪物，可能减少矩形的面积。具体来说，可以尝试移除一个怪物，然后计算剩余怪物的最小包围矩形，再考虑如何移动被移除的怪物以进一步减少面积。 代码解析 输入处理： 读取怪物数量n和每个怪物的坐标(x[i], y[i])。 使用两个多重集合s和t分别存储所有x坐标和y坐标。 特殊情况处理： 如果n ≤ 2，直接返回n，因为无论怎么移动，最小矩形面积至少为n（因为至少需要覆盖所有怪物）。 遍历每个怪物： 对于每个怪物i，暂时将其从集合中移除。 计算剩余n-1个怪物的最小包围矩形的面积：lx * ly，其中lx是x坐标的跨度，ly是y坐标的跨度。 如果lx * ly == n - 1，说明剩余n-1个怪物已经紧密排列，此时移动怪物i可以有两种选择： 将怪物i移动到x方向扩展后的位置，面积可能变为(lx + 1) * ly。 将怪物i移动到y方向扩展后的位置，面积可能变为(ly + 1) * lx。 否则，移动怪物i后的最小面积就是lx * ly。 将怪物i重新插入集合，继续处理下一个怪物。 输出结果： 最终结果是所有可能情况中的最小值，但至少为n（因为至少需要覆盖所有怪物）。 代码总结 核心思想：通过枚举每个怪物作为被移动的怪物，计算剩余怪物的最小包围矩形，并考虑移动后的可能优化。 时间复杂度：O(n log n)，因为每次插入和删除操作在multiset中是O(log n)，共进行n次。 空间复杂度：O(n)，用于存储坐标和多重集合。 示例 假设有3个怪物在(1,1), (2,2), (3,3)： 移除(1,1)后，剩余矩形是(2,2)到(3,3)，面积4。移动(1,1)到(1,2)或(2,1)可以使新矩形面积变为4或6，最小为4。 类似地，移除其他怪物也会得到面积4。 最终最小金币数为4。 但根据代码逻辑，如果lx * ly == n - 1（即2 == 2），会尝试(lx + 1) * ly和(ly + 1) * lx（即3*2=6和3*2=6），但原始面积已经是4，所以最终结果为4。
#### 代码：
```cpp
//multiset可以重复，两个怪物可以在同一行或同一列
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const int N=2e5+7;
ll x[N],y[N];
void solve(){
multiset<int>s,t;
ll n,ans=1e18; cin>>n; 
for(int i=1;i<=n;++i){
    cin>>x[i]>>y[i];
    s.insert(x[i]); t.insert(y[i]);
}  
if(n<=2){cout<<n<<endl;return;}
for(int i=1;i<=n;++i){
    s.erase(s.find(x[i])); t.erase(t.find(y[i]));
    ll lx=*s.rbegin()-*s.begin()+1;
    ll ly=*t.rbegin()-*t.begin()+1;
    if(lx*ly==n-1){
        ans=min({ans,(lx+1)*ly,(ly+1)*lx});
    }
    else ans=min(ans,lx*ly);//要有ans,看移动的是哪一个
    s.insert(x[i]); t.insert(y[i]);
}
cout<<max(ans,n)<<endl;
}
signed main(){
    int T=1;
    cin>>T;
    while(T--)solve();
    return 0;
}

```
## [1027E](https://codeforces.com/contest/2114/problem/E)