
# [Codeforces 1023 (Div. 2)](https://codeforces.com/contest/2107)
## [1023A](https://codeforces.com/contest/2107/problem/A)
## [1023D](https://codeforces.com/contest/2107/problem/D)
```cpp
#include<bits/stdc++.h>
#define fi first
#define se second
using namespace std;
typedef long long ll;
typedef pair<int,int>pii;
typedef pair<ll,ll>pll;
const ll p=998244353;
//序列大小（字典序）
//开始要找树的直径
//然后最大节点
void solve(){
    int n;cin>>n;
    vector<vector<int>>g(n+1);
    vector<array<int,3>>ans;
    vector<int>vis(n+1);
    vector<int>p(n+1);
    for(int i=1;i<=n-1;i++){
        int u,v;cin>>u>>v;
        g[u].push_back(v),g[v].push_back(u);
    }
    auto dfs=[&](auto &&dfs,int fa,int u)->pii{
        pii tmp={1,u};//找树的直径的函数
        p[u]=fa;
        for(auto v:g[u]){
            if(vis[v]||v==fa) continue;
            auto t=dfs(dfs,u,v);
            t.fi+=1;
            tmp=max(tmp,t);//保证每次返回最长且顶点序列最大的一个
        }
        return tmp;
    };
    while(1){
        if(count(vis.begin()+1,vis.end(),0)==0) break;
        for(int i=1;i<=n;i++){
            if(vis[i]) continue;
			//找到没有被遍历的节点i,并找到相关的直径
            auto [_,u]=dfs(dfs,-1,i);
            auto [d,v]=dfs(dfs,-1,u);
/*
auto [_, u]解构了这个pair(返回值为pair的两个元素)：
_是一个占位符变量，表示忽略第一个成员（路径长度）
u绑定到第二个成员（最远节点）。
为什么用 _？这是一种约定俗成的写法，表示“这个变量不重要，故意忽略它”。*/
            ans.push_back({d,max(u,v),min(u,v)});
            while(v!=-1){
                vis[v]=1;
                v=p[v];
            }
        }
    }
    sort(ans.begin(),ans.end(),greater<array<int,3>>());
    for(auto [d,u,v]:ans){
		cout<<d<<' '<<u<<' '<<v<<' ';
	}
}
int main(){
	int T=1;cin>>T;
	while(T--){
		solve();
		cout<<endl;
	}
}

```
## [1023E](https://codeforces.com/contest/2107/problem/E)
###### 解析
lca:最近公共祖先对应的节点（也就是深度最大的公共祖先）
dep:最近公共祖先对应的节点的深度
对于直线树，`LCA(i, j) = min(i, j) = i`（因为i < j），所以`dep(LCA(i, j)) = dep(i) = i - 1`。因此，重量可以表示为： 
![[微信图片_20250509151545 1.jpg]]
*为什么减少量是C(m, 2)
- 子树中有m个节点，任意两个节点形成一个节点对。    
- 每个节点对的LCA深度减少了相同的量（因为它们的LCA都从某个节点变为x）。
- 每次从子节点中挑两个，每次减少1， 因此，总减少量正比于子树中的节点对数量，即C(m, 2)。
#### 代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define int long long//写全
#define endl '\n'
void solve(){
  int n; cin >> n;
        int k; cin >> k;
        int mx = n * (n - 1) * (n - 2) / 6;
        if (k > mx + 1){
            cout << "No\n";
            return ;
        }
        cout << "Yes\n";
        k = mx - min(k, mx);
        int p = n - 1;
        for (int i = n; i >= 2; i--){
            while (p * (p - 1) / 2 > k) p--;
            k -=  p * (p - 1) / 2;
            cout << (i - p) << " " << i << "\n";//将节点i移动到节点(i-p);
            if (p != 1) p--;
        }
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    cin >> T;
    while (T--)solve();
    return 0;
}
```