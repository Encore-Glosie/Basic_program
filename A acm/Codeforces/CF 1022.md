
# [ Codeforces 1022 (Div. 2)](https://codeforces.com/contest/2108)
## [1022A](https://codeforces.com/contest/2108/problem/A)
###### 解析 

数学推导：f(p) = Σ|p_i - i| 的不同值数量

1. 定义与观察  
    排列p：{1,2,...,n}的一个排列  
    函数f(p)：所有|p_i - i|的和  
    目标：求f(p)的所有可能值的数量
2. 极值分析  
    最小值f_min：  
    当p_i = i（恒等排列）时，f(p)=0  
    这是唯一能使f(p)=0的情况  
    最大值f_max：  
    当排列完全逆序时（p_i = n-i+1），f(p)最大  
    计算：  
    偶数n：f_max = n²/2  
    奇数n：f_max = (n²-1)/2
3. 值的分布规律  
    关键观察：  
    f(p)的所有可能值是偶数  
    从0到f_max，所有偶数都可能出现，但某些情况可能跳过部分值  
    数学归纳：  
    偶数n=2k：  
    不同值数量为k²+1  
    奇数n=2k+1：  
    不同值数量为k(k+1)+1
4. 构造性证明  
    通过交换排列中的元素，可以系统性地生成不同的f(p)值  
    例如交换p_i和p_j会使f(p)变化2|i-j|
5. 最终公式  
    偶数n：不同值数量 = (n/2)² + 1  
    奇数n：不同值数量 = （n/2)[(n/2)+1] + 1  
    结论  
    该问题的解基于排列的逆序性质和数学归纳，通过极值分析和构造排列得出公式。代码直接计算公式，时间复杂度O(1)，适用于大n。
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
int n;
void solve(){ 
	cin>>n;
	int k=n/2;
	if(n&1)cout<<k*(k+1)+1<<endl;
	else cout<<k*k+1<<endl;
}
signed main(){
	ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
	int T = 1;
	cin >> T;
	while (T--)solve();
	return 0;
}
```
## [1022C](https://codeforces.com/contest/2108/problem/B)
###### 点击查看分析
问题描述  
给定两个整数 n 和 x，构造一个长度为 n 的正整数数组 a，使得数组中所有元素的异或结果为 x，并且数组的元素和最小。最终只需要输出这个最小的和。
异或操作的性质 异或（XOR）操作有以下重要性质：
交换律和结合律：a ⊕ b = b ⊕ a，(a ⊕ b) ⊕ c = a ⊕ (b ⊕ c)
自反性：a ⊕ a = 0，a ⊕ 0 = a
分配性：异或操作可以按位进行
构造数组的思路  
为了使数组的和最小，我们需要尽量使用小的数。以下是构造数组的核心思路：
直接构造：
如果 n = 1，则数组只能是 [x]，此时和为 x
如果 n = 2，可以构造 [x ⊕ 1, 1]，和为 (x ⊕ 1) + 1
利用异或的自反性：
如果 n ≥ 3，可以通过添加成对的相同数来调整异或结果
为了使和最小，可以尽量使用 1
关键观察：
设 x 的二进制表示中有 k 个 
如果 n ≥ k，可以先用 k 个数构造出 x，然后用 n - k 个 1 来填充剩余的位置
如果 n - k 是偶数，直接添加 (n - k)/2 对 1 即可
如果 n - k 是奇数，需要调整策略：
可以尝试用 3 来替代部分 1
可以添加 1、3 和 (n - k - 2)/2 对 1
特殊情况处理  
x = 0：
如果 n = 1，无法构造，输出 -1
如果 n ≥ 2：
如果 n 是偶数，直接输出 n
如果 n 是奇数，可以构造 [2, 3, 1, ..., 1]，和为 n + 3
x = 1：
如果 n = 1，输出 1
如果 n ≥ 2：
如果 n 是奇数，可以构造 [1, 1, ..., 1]，和为 n
如果 n 是偶数，可以构造 [2, 3, 1, ..., 1]，和为 n + 3
算法步骤  
计算 x 的二进制中 1 的位数 k
根据 n 和 k 的关系：
如果 n ≤ k，直接输出 x
如果 n > k：
如果 n - k 是偶数，输出 x + (n - k)
如果 n - k 是奇数：
n - k 为奇数时的详细解释  
问题背景  
关键变量  
k：x 的二进制中 1 的位数（__builtin_popcountll(x)）
n - k：需要额外填充的数字个数
当 n - k 为奇数时的问题  
目标：填充 n - k 个数，使得它们的异或不影响 x（即异或为 0）
问题：
如果 n - k 是奇数，直接填充 1 会导致异或为 1（因为 1 ⊕ 1 ⊕ 1 = 1），这会破坏总异或结果
因此，不能简单地用 1 填充，需要调整策略
解决方法  
为了保持总异或为 x，我们需要让填充的数的异或为 0。当 n - k 为奇数时，可以采取以下策略：
引入 3 和 1：
1 ⊕ 3 = 2，因此可以用 1 和 3 来调整异或结果
填充 1、3 和 (n - k - 2)/2 对 1
最小和的计算：
最小和 = x + (n - k) + 1（如果 x > 1）
特殊情况：
x = 1：
填充 2、3 和 n - 2 个 1，和为 n + 3
x = 0：
填充 1、2、3 和 n - 3 个 1，和为 n + 3
- 示例验证  
    n x 构造示例  
    5 3 [2, 1, 1, 1, 2]  
    4 1 [2, 3, 1, 1]  
    5 0 [1, 2, 3, 1, 1]

总结  
n ≤ k 时：直接分解 x，和为 x
n > k 时：
如果 n - k 是偶数，添加 (n - k)/2 对 1，和为 x + (n - k)
如果 n - k 是奇数：
如果 x > 1，和为 x + (n - k) + 1
如果 x = 1，和为 n + 3
如果 x = 0：
n = 1：无法构造（输出 -1）
否则，和为 n + 3
#### 代码：
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long;
void solve(){
    int n,x;
	cin>>n>>x;
    int k=__builtin_popcountll(x);
    if (n<=k){cout<<x<<endl;return;}
    if ((n-k)%2==0)cout<<x+n-k;
    else{ 
		if (x>1){cout<<x+n-k+1;return;}
        if (x==1){cout<<n+3;return;}
        else{
			if (n==1){cout<<-1;return;}
            else cout<<n+3;
        }
    }
}
signed main(){
   ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T=1; 
    cin>>T;
    while (T--){solve(); cout<<endl;}
	return 0;
}
```
##  [1022C](https://codeforces.com/contest/2108/problem/C)
#### 代码
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//找到峰值(局部最大值-严格大于其相邻元素的元素)
//通过找峰值(比较相邻元素)可以找到一个有序序列的最值
void solve(){
        int n; cin >> n;
        vector<int> a;
        a.push_back(-1);//哨兵
        for (int i = 0; i < n; ++i){
            int x; cin >> x;
            if (a.back()!= x)a.push_back(x);
        }
        a.push_back(-1);
        int ans=0;
        for (int i=1; i<a.size()-1; ++i) 
            if (a[i-1] < a[i] && a[i] > a[i+1]) ++ans;
        cout <<ans<< endl;
    }
signed main(){
   ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T=1; 
    cin>>T;
    while (T--){solve();}
	return 0;
}



```