# C
https://codeforces.com/contest/2102/problem/C
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250512190102445-165669157.png)

<details>
<summary>点击查看解题思路</summary>
解题思路
为了最大化 MEX 的总和，我们需要考虑如何让尽可能多的子网格包含连续的数字从 0 开始。因为：

如果一个子网格包含 0, 1, ..., k-1，但不包含 k，那么它的 MEX 是 k。

更大的 k 会贡献更大的 MEX 值。

因此，我们需要让小的数字（尤其是 0, 1, 2, ...）尽可能地集中在某些区域，这样包含这些数字的子网格可以有较高的 MEX。

观察给定代码
给定的代码是一个螺旋填充的算法：

从外向内螺旋填充数字，从最大的数字 
n^2−1 开始递减。

对于偶数 n，螺旋会完整填充；对于奇数 n，中心会剩下一个格子填充 0。
为什么螺旋填充？
螺旋填充的目的是将较大的数字放在外围，较小的数字放在内层。这样：

小的数字（尤其是 0）集中在中心。

任何包含中心的子网格会包含 0，因此 MEX 至少为 1。

如果子网格包含 0 和 1，MEX 至少为 2，以此类推。

这种排列方式可以最大化包含连续小数字的子网格数量，从而最大化 MEX 的总和。
</details>

代码：
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
void solve() {
    int n;//螺旋填充法
    cin>>n;
    vector<vector<int>> a(n,vector<int>(n));//二维数组
    int c=n*n-1;
    for (int i=0;i<n/2;i++) {//填充
        for (int j=i;j<n-i;j++) a[i][j]=c--;//上
        for (int j=i+1;j<n-i;j++) a[j][n-i-1]=c--;//右
        for (int j=n-i-2;j>=i;j--) a[n-i-1][j]=c--;//下
        for (int j=n-i-2;j>i;j--) a[j][i]=c--;//左
    }
    if(c==0) a[n/2][n/2]=c;//中心是否为0
    for (int i=0;i<n;i++) {
        for (int j=0;j<n;j++) cout<<a[i][j]<<" ";
        cout<<endl;
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    cin >> T;
    while (t--) solve();
    return 0;
}

```
# D
https://codeforces.com/contest/2102/problem/D
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250513185137465-1104100133.png)

<details>
<summary>点击查看解析</summary>

![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250513185345977-499299732.png)
</details>

代码：
```cpp
##include<bits/stdc++.h>
using namespace std;
#define endl '\n'
#define lowbit(x) (x&(-x))
#define vi vector<int>
const int N=2e5+7;
int tr[N];
int n;//里用树状数组好用来统计插入一个数后整个数组逆序数的变化
int add(int x,int k){//最小从1开始
   for(int i=x;i<=n;i+=lowbit(i))tr[i]+=k;
}
void sum(int x){//逆序数
    int ans=0;
    for(int i=x;i;i-=lowbit(i))ans+=tr[i];
    return ans;
}
void solve(){
    cin>>n;
    vi a(n),odd,even;
    for(int i=0;i<n;++i){
        cin>>a[i];
        if(!(i&1))odd.emplace_back(a[i]);//直接填充，如果odd(n)会直接从n+1开始填充
        else even.emplace_back(a[i]);
    }
    auto acc=[&](vi vc){//from 1//lambda函数可以直接内嵌在别的函数中
      int sz=vc.size();
      if(sz<=1)return 0;
      vi vt=vc;
      sort(vt.begin(),vt.end());
      for(auto &x: vc)//离散化处理//存位置renew vc//在下面已经排过序了
        x=lower_bound(vt.begin(),vt.end(),x)-vt.begin()+1;
      for(int i=1;i<=sz;++i)tr[i]=0;//清0
      int ans=0;
      for(int i=sz-1;i>=0;--i){
        ans+=sum(vc[i]-1);//-1严格小于当前的数
        add(vc[i],1);
      }
      return ans;
    };//内嵌函数可以看作一个语句了
    int ans1=acc(odd), ans2=acc(even);
    sort(odd.begin(),odd.end());
    sort(even.begin(),even.end());
    vi ans(n);
    for(int i=0;i<odd.size();++i)ans[2*i]=odd[i];//ans[0]是第一位
    for(int i=0;i<even.size();++i)ans[2*i+1]=even[i];
    if((ans1+ans2)&1)swap(ans[n-3],ans[n-1]);
    for(int i=0;i<n;++i)cout<<ans[i]<<" \n"[i==n-1];//索引
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    cin>>T;
    while(T--)solve();
    return 0;
}


```
