# A
https://codeforces.com/contest/2098/problem/A
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250510225953750-287541658.png)
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250510230024588-732649047.png)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
//#define int long long
//#define ll long long
void solve(){
 string s;
 cin >> s;
 sort(s.begin(), s.end());//按升序排列
 for(int i=9; i>=0; --i){
	int x=lower_bound(s.begin(),s.end(),i+'0')-s.begin();
	cout << s[x];
	s.erase(s.begin() + x);
 }
 cout << endl;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T=1;
	cin>>T;
	while(T--)solve();
	return 0;
}
```
#B
https://codeforces.com/contest/2098/problem/B
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250511154947729-269136269.png)

<details>
<summary>点击查看酒吧舞</summary>
1.注意街上的房子数和序号已经固定即1~1e9,
2.然后是酒吧的位于的房号，即7 7 表示7号房中有两个酒吧关了一个7号房还是会有一个酒吧
3.k是不确定的,f(x)也是不确定的，求的是所有可能的情况，即所有中位数的位置的情况
4.找的是酒吧个数的中位数，然后看它所在的房间，处于酒吧中位数的所有房间与其他酒吧的f(x)是都相等的
5.通过计算发现偶数的0.5左边和右边的f(x)相等，所有小取小，大取大，保证全部取到
6。奇数的中位数是（奇数/2）+1
7.对于右边的中位数=(n-k)/2+1+k=(n+k+2)/2
8.找n-k后的中位数  滑动窗口
</details>

```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl '\n'
//#define int long long
//#define ll long long
void solve(){
int n, k;
cin >> n >> k;
vector<int> a(n+1);
for(int i=1; i<=n; ++i) cin >> a[i];
sort(a.begin()+1, a.end());
int l=(n - k + 1)/2;
int r=(n + k + 2)/2;
cout << a[r]-a[l]+1<<endl;
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T=1;
	cin>>T;
	while(T--)solve();
	return 0;
}

```
# C
https://codeforces.com/contest/2098/problem/C
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250511200423626-1788642274.png)

<details>
<summary>点击查看真心话</summary>
//在第ai天打赌，不是统一预测好几天，可以跟据ai天的飞行预测ai+1和ai+2
//这一天被猜测三次或者，前两天被猜过(或者前一天出现过两次)然后要猜今天的两次 
//即让某一天被猜的次数超过三次且
//或让天数是连续的出现两个天是被连续猜两次的(利用取连续性即即可推出答案)
//记录出现两次的天数，如果来连续就传递下去
//大数用不了哈希用map来存下标！map!!
</details>

```cpp
#include<bits/stdc++.h>
using namespace std;
map<int,int>a1,a2;
void solve(){
	a1.clear(),a2.clear();
	int n; cin>>n;
 vector<int>a(n+1);
 for(int i=1;i<=n;++i)cin>>a[i],++a1[a[i]];
 sort(a.begin()+1,a.end());
 for(int i=1;i<=n;++i){
	if(a1[a[i]]>3||(a1[a[i]]>1&&a2[a[i]-1])){
		cout<<"Yes\n";
		return ;
	}
	if(a1[a[i]]>1||(a1[a[i]]&&a2[a[i]-1]))a2[a[i]]=1;
 }
 cout<<"No\n";
}
signed main(){
	ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
	int T=1;
	cin>>T;
	while(T--) solve();
	return 0;
}
```
# D
https://codeforces.com/contest/2098/problem/D
![image](https://img2024.cnblogs.com/blog/3627480/202505/3627480-20250511210738390-1609284139.png)

```cpp
//题目可以概括为给定一些坐标然后找一些与之相邻的坐标把它们都串通起来
#include<bits/stdc++.h>
using namespace std; const int N = 1e6 + 5, M = 1e9 + 7;
int t, n, m, k, x, y, lx, ly, a, b, c, d, dsu[N], nn[N], ne[N], sl[N], ans;
int get(int u){ return u == dsu[u] ? u : dsu[u] = get(dsu[u]); }
void mrg(int a, int b){
    int c = (a == b); a = get(a), b = get(b);
    if (a == b) ne[a]++, sl[a] |= c;
    else dsu[a] = b, nn[b] += nn[a], ne[b] += (1 + ne[a]), sl[b] |= sl[a];
}
int main(){
    for (cin >> t; t--; cout << ans << "\n"){
        cin >> n >> m >> k >> lx >> ly;
        for (y = ans = 1; y <= n * m; y++) dsu[y] = y, nn[y] = 1, ne[y] = sl[y] = 0;
        while (k--){  cin >> x >> y;
            if (abs(x - lx) + abs(y - ly) != 2) ans = 0;
            if (x == lx) a = c = x, b = d = (y + ly) / 2;
            else if (y == ly) a = c = (x + lx) / 2, b = d = y;
            else a = x, b = ly, c = lx, d = y;
            mrg((a - 1) * m + b, (c - 1) * m + d), lx = x, ly = y;
        }
        for (y = 1, x = get(y); y <= n * m; y++, nn[x] = 0, x = get(y))
            if (nn[x]) if (ne[x] > nn[x]) ans = 0;
            else if (ne[x] == nn[x]) ans = ans * (sl[x] ? 1 : 2) % M;
            else ans = 1LL * ans * nn[x] % M;
    }
}
```
