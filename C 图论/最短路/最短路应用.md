# [P4042 [AHOI2014/JSOI2014] 骑士游戏 - 洛谷](https://www.luogu.com.cn/problem/P4042)
```cpp
思路：利用spfa()遍历更新所有怪兽死亡所需要的最小体力值
双向链表只是路径不同，无法维护父节点与子节点之间的关系(可能会反向遍历本该没有的产生的小怪兽)
两个链式前向星的作用：
计算普通攻击的总消耗：对于怪兽 u，需要遍历它的所有出边（普通攻击产生的新怪兽），累加这些新怪兽的最小体力值。
通知依赖节点更新：当怪兽 u 的最小体力值被更新时，需要通知所有依赖它的节点（即哪些节点的普通攻击会产生 u）重新计算。
这两种操作分别对应正向边和反向边的遍历。

#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long
const int N=2e5+7,M=1e6+5;
int h[N],e[M],ne[M],hf[N],ef[M],nef[M];
int st[N],idx,idxf,n,r;
ll phy[N],mgc[N];
void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
void addf(int a,int b){
    ef[idxf]=b;
    nef[idxf]=hf[a];
    hf[a]=idxf++;
}
ll spfa(){
    queue<int>q;
    for(int i=1;i<=n;++i)q.push(i);//所有的点都入队确保更新所有的怪兽
    memset(st,1,sizeof st);
    while(!q.empty()){
        int t=q.front();
        q.pop();
        st[t]=0;
        ll res=phy[t];
        for(int i=h[t];i!=-1;i=ne[i])res+=mgc[e[i]];
        if(mgc[t]>res){//魔法攻击造成的死亡与物理攻击造成的彻底死亡
            mgc[t]=res;//这里松弛操作使mgc是最终的答案；
            for(int i=hf[t];i!=-1;i=nef[i])
            if(!st[ef[i]]){
               st[ef[i]]=1;
                q.push(ef[i]);//放入队列更新其他节点
            }   
        }
    }
    return mgc[1];
}
void solve(){
    memset(h,-1,sizeof h);
    memset(hf,-1,sizeof hf);
     int b; ll s,k; cin>>n;
    for(int a=1;a<=n;++a){
        cin>>s>>k>>r;
        phy[a]=s; mgc[a]=k;
        while(r--){
            cin>>b;
            add(a,b);
            addf(b,a);
        }
    }
   cout<<spfa()<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long
const int N=2e5+7,M=1e6+5;
int h[N],e[M],ne[M],hf[N],ef[M],nef[M];
int st[N],idx,idxf,n,r;
ll phy[N],mgc[N];
void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
void addf(int a,int b){
    ef[idxf]=b;
    nef[idxf]=hf[a];
    hf[a]=idxf++;
}
ll spfa(){
    queue<int>q;
    for(int i=1;i<=n;++i)q.push(i);//所有的点都入队确保更新所有的怪兽
    memset(st,1,sizeof st);
    while(!q.empty()){
        int t=q.front();
        q.pop();
        st[t]=0;
        ll res=phy[t];
        for(int i=h[t];i!=-1;i=ne[i])res+=mgc[e[i]];
        if(mgc[t]>res){//魔法攻击造成的死亡与物理攻击造成的彻底死亡
            mgc[t]=res;//这里松弛操作使mgc是最终的答案；
            for(int i=hf[t];i!=-1;i=nef[i])
            if(!st[ef[i]]){
               st[ef[i]]=1;
                q.push(ef[i]);//放入队列更新其他节点
            }   
        }
    }
    return mgc[1];
}
void solve(){
    memset(h,-1,sizeof h);
    memset(hf,-1,sizeof hf);
     int b; ll s,k; cin>>n;
    for(int a=1;a<=n;++a){
        cin>>s>>k>>r;
        phy[a]=s; mgc[a]=k;
        while(r--){
            cin>>b;
            add(a,b);
            addf(b,a);
        }
    }
   cout<<spfa()<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```


# [P1606 [USACO07FEB] Lilypad Pond G - 洛谷](https://www.luogu.com.cn/problem/P1606)
```cpp
用图论建模，把 “可跳跃到达的连通区域” 抽象为节点，跳跃关系抽象为边
实际代码中，用 p[i][j] = (i-1)*m + j 给每个网格（包括莲花、水域）分配唯一编号，作为图的节点。
若从节点 A 能跳到节点 B（或对应的水域区域），则添加边 A→B 。
起点d为0，但是要把重点的莲花减掉

#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
#define ll long long
const int inf=0x3f3f3f3f;
const int N=4e1+5,M=N*N;
int dx[8]={2,1,-1,-2,-2,-1,1,2}, dy[8]={1,2,2,1,-1,-2,-2,-1};
int h[M],e[M*M],ne[M*M],st[M],p[N][N],mp[N][N],vis[N][N],dis[M],n,m,idx,sta,ed;
ll cnt[M];//不开longlong见祖宗
void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
void dfs(int s,int x,int y){
    vis[x][y]=1;
    for(int i=0;i<8;++i){
        int xx=x+dx[i],yy=y+dy[i];
        if(xx<1||yy<1||xx>n||yy>m||vis[xx][yy])continue;//vis放后面可以防止越界
        if(mp[xx][yy]==1)dfs(s,xx,yy);//莲花直接跳//下一个递归会完成vis的标记
        else vis[xx][yy]=1,add(s,p[xx][yy]);//无法跳的区域建立连通块
    }
}
void spfa(){
    memset(dis,inf,sizeof dis);
    queue<int>q;
    dis[sta]=0; q.push(sta); st[sta]=1; cnt[sta]=1;
    while(!q.empty()){
        int t=q.front();
        q.pop(); st[t]=0;
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(dis[j]>dis[t]+1){
                dis[j]=dis[t]+1;
                cnt[j]=cnt[t];//继承；
                if(!st[j]){
                    st[j]=1;
                    q.push(j);
                }
            }
            else if(dis[j]==dis[t]+1)
                cnt[j]+=cnt[t];//路径累加
        }
    }
}
void solve(){
    memset(h,-1,sizeof h);
    cin>>n>>m;
    for(int i=1;i<=n;++i)
     for(int j=1;j<=m;++j){//二维转一维的常用方法
       p[i][j]=(i-1)*m+j;//前面i-1行总共有(i-1)*m个格子
       cin>>mp[i][j];
       if(mp[i][j]==3)sta=p[i][j];
       if(mp[i][j]==4)ed=p[i][j];
     }
    for(int i=1;i<=n;++i)
     for(int j=1;j<=m;++j)
      if(mp[i][j]==3||mp[i][j]==0){
        memset(vis,0,sizeof vis);
        dfs(p[i][j],i,j);//进入深搜建立连通块
      }
      spfa();
      if(dis[ed]==inf)cout<<-1<<endl;
      else cout<<dis[ed]-1<<endl<<cnt[ed]<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```