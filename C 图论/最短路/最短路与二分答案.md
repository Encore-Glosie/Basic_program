
# [P1948 [USACO08JAN] Telephone Lines S - 洛谷](https://www.luogu.com.cn/problem/P1948)
```cpp
链式前向星相关数组
可以免费选 k 条边（这 k 条不计入支出）。
总支出是剩余需要付费的边中最长的那条的长度（若付费边数 ≤k，支出为 0）

我们的目标是找到最小的 mid，使得存在一条路径满足：
所有付费边的长度 ≤mid（这样总支出 ≤mid）
付费边的数量 ≤k（或通过免费权限覆盖，使总支出为 0）

>=mid使用k和谐掉，<mid不用管以mid为最长付费

#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
const int N = 1e3+5,M = 2e4+5;
int h[N], e[M], ne[M], w[M], idx,  n, p, k, dis[N], st[N];
void add(int a, int b, int c) {
    e[idx] = b;
    w[idx] = c;
    ne[idx] = h[a];
    h[a] = idx++;
}
bool check(int mid) {
    memset(dis, 0x3f, sizeof(dis));
    memset(st, 0, sizeof(st));
    queue<int> q;
    dis[1] = 0;
    q.push(1);
    st[1] = 1;
    while (!q.empty()) {
        int t = q.front();
        q.pop();
        st[t] = 0;
        for (int i = h[t]; i != -1; i = ne[i]) {
            int j = e[i];
            int newDis;
            if (w[i] > mid) 
             newDis = dis[t] + 1;
             else
              newDis = dis[t];
            if (newDis < dis[j]) {//找最短
                dis[j] = newDis;
                if (!st[j]) {
                    q.push(j);
                    st[j] = true;
                }
            }
        }
    }
    return dis[n] <= k;
}

signed main() {
    memset(h, -1, sizeof(h));
    cin >> n >> p >> k;  int a, b, c;
    for (int i = 0; i < p; i++) {
        cin>>a>>b>>c;
        add(a, b, c);
        add(b, a, c);  
    }
    int l = 0, r = 1000000, ans = -1;
    while (l <= r) {
        int mid = (l + r) / 2;
        if (check(mid)) {
            ans = mid;
            r = mid - 1;
        } 
        else 
            l = mid + 1;
    }
    cout<<ans<<endl;
    return 0;
}
```