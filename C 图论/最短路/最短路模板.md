## [853. bellman_ford求最短路(有边数限制的最短路) - AcWing](https://www.acwing.com/problem/content/855/)
#### 特点：O(nm)，struct+memcpy
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=5e2+5,M=1e4+5;
int dist[N],back[N],n,m,k;
struct Edge{
    int a;
    int b;
    int w; 
}e[M];
int bellman_ford(){
    memset(dist,inf,sizeof dist);
    dist[1]=0;
    for(int i=0;i<k;++i){//如果没有k就要进行n-1轮松弛操作
    memcpy(back,dist,sizeof dist);
    for(int j=0;j<m;++j){//从0开始,0的下一条边是1,m没有下一条边
        int a=e[j].a, b=e[j].b, w=e[j].w;
        dist[b]=min(dist[b],back[a]+w);//防止串联，循环k次,每次只更新相邻一条的边
    }
    }//不能return -1了，因为答案可能是-1
    return dist[n];
}
void solve(){
    int a,b,c;
    cin>>n>>m>>k;
    for(int j=0;j<m;++j){
       cin>>a>>b>>c;
       e[j]={a,b,c};
    }
    int f=bellman_ford();
    if(f>inf/2)cout<<"impossible\n";
    else cout<<f<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```

## 2.spfa求最短路(有负边权)
## [851. spfa求最短路 - AcWing题库](https://www.acwing.com/problem/content/853/)
#### 特点：最坏O(nm)，利用队列，每次只处理一个；只用处理邻接点而不是每次遍历所有节点，未排序则需重复利用st[t]=0,而dijkstra利用优先队列就无需反复置零
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=1e5+7;
int e[N],h[N],ne[N],w[N],dist[N],st[N],n,m,idx;
void add(int a,int b,int c){
    w[idx]=c;
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int spfa(){
    memset(dist,inf,sizeof dist);
    dist[1]=0;
    queue<int>q;
    q.push(1); 
    while(!q.empty()){
    int t=q.front();
    q.pop();
    st[t]=0;//队列里是否有t，拿出则无
     //要是无权图的化就不用st多次入队了，类似bfs，第一个访问到的节点即为最短
    for(int i=h[t];i!=-1;i=ne[i]){
        int j=e[i];//j可能已经被遍历过了，是可以直接先比较的
        if(dist[j]>dist[t]+w[i]){//t是当前节点，i是下一个节点，i是邻边
        dist[j]=dist[t]+w[i];
        if(!st[j]){
        q.push(j);
        st[j]=1;
         }
         //只有当大于是才会有以上这些处理
      }
    }
  }
  return dist[n];
}
void solve(){
    memset(h,-1,sizeof h);
    int m,a,b,c;
    cin>>n>>m;
    while(m--){
    cin>>a>>b>>c;
    add(a,b,c);
    }
   int f=spfa();
   if(f>inf/2)cout<<"impossible\n";
   else cout<<f<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```
## [AcWing 852. spfa判断负环 - AcWing](https://www.acwing.com/activity/content/problem/content/921/)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=2e3+5,M=1e4+5;
int e[M],h[N],ne[M],w[M],dist[N],st[N],cnt[N],n,idx;
void add(int a,int b,int c){
    w[idx]=c;
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int spfa(){
    memset(dist,inf,sizeof dist);
    dist[1]=0;
    queue<int>q;//因为点1可能到不了有负环的点,因此把所有点都加入队列
    for(int i=1;i<=n;++i){
        st[i]=1; 
        q.push(i);
    }
    while(!q.empty()){
    int t=q.front();
    q.pop();
    st[t]=0;
    for(int i=h[t];i!=-1;i=ne[i]){
        int j=e[i];
        if(dist[j]>dist[t]+w[i]){//t是当前节点，是下一个节点，i是邻边
        dist[j]=dist[t]+w[i];
        cnt[j]=cnt[t]+1;
        if(cnt[j]>n)return 1;//路径计数//或下面
        if(!st[j]){
        //++cnt[j];if()...
        q.push(j);
        st[j]=1;
         }
      }
    }
  }
  return 0;
}
void solve(){
    memset(h,-1,sizeof h);
    int m,a,b,c;
    cin>>n>>m;
    while(m--){
    cin>>a>>b>>c;
    add(a,b,c);
    }
   cout<<(spfa()?"Yes":"No")<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```
## [854. Floyd求最短路 - AcWing](https://www.acwing.com/problem/content/856/)
```cpp
#include<bits/stdc++.h>
using namespace std;
const int inf=0x3f3f3f3f;
const int N=2e2+10;
int d[N][N],n;
void floyd(){
    for(int k=1;k<=n;++k)
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
    d[i][j]=min(d[i][j],d[i][k]+d[k][j]);  
}
void solve(){
    int m,a,b,c,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;++i)
    for(int j=1;j<=n;++j)
        if(i==j)d[i][j]=0;
        else d[i][j]=inf;
    while(m--){
        cin>>a>>b>>c;
        d[a][b]=min(d[a][b],c);
    }
    floyd();
    while(q--){
        cin>>a>>b;
        if(d[a][b]>inf/2)cout<<"impossible\n";
        else cout<<d[a][b]<<"\n";
    }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```
### [P3385负环(涉及初始化问题) - 洛谷](https://www.luogu.com.cn/problem/P3385)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define ll long long
const int inf=0x3f3f3f3f;
const int N=1e4+7,M=1e4+7;
int e[M],h[N],ne[M],st[N],dist[N],w[M],cnt[N],idx,n,m;
void add(int a,int b,int c){
    w[idx]=c;
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
int spfa(){
    memset(dist,inf,sizeof dist);
    memset(cnt,0,sizeof cnt);
    memset(st,0,sizeof st);
    //尽量都在独立的函数中初始化，不然容易造成数据污染
    idx=1;
    dist[1]=0;
    queue<int>q;
    q.push(1);
    while(!q.empty()){
        int t=q.front();
        q.pop();st[t]=0;
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(dist[j]>dist[t]+w[i]){
                dist[j]=dist[t]+w[i];
                cnt[j]=cnt[t]+1;
                if(cnt[j]>n-1)return 1;
                if(!st[j]){
                    st[j]=1;
                    q.push(j);
                }
            }
        }
    } 
    return 0;
}

void solve(){
    memset(h,-1,sizeof h);
    idx=0;
    //下面会用到add函数，所以必须在这里初始化add相关的变量
   int a,b,c;
   cin>>n>>m;
   while(m--){
    cin>>a>>b>>c;
    add(a,b,c);
    if(c>=0)add(b,a,c);
   }
   cout<<(spfa()?"YES\n":"NO\n");
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    cin>>T;
    while(T--)solve();
    return 0;
}
```

### 有话说：
#### *求最长路径时可以把边权w转为负的，即-w,然后直接按追段路径求即可*
