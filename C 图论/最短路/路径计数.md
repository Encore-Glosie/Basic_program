
# [洛谷图论大礼包](https://www.luogu.com.cn/training/14206#information)
## 最短路径及计数

#### [P1144 最短路计数 - 洛谷](https://www.luogu.com.cn/problem/P1144)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define ll long long
const int inf=0x3f3f3f3f,mod=100003;
const int N=1e6+7,M=2e6+7;
int e[M],h[N],ne[M],st[N],dist[N],cnt[N],idx,n,m;
void add(int a,int b){
    e[idx]=b;
    ne[idx]=h[a];
    h[a]=idx++;
}
void spfa(){
     memset(dist,inf,sizeof dist);
     dist[1]=0; cnt[1]=1;
     queue<int>q;
     q.push(1); st[1]=1;
     while(!q.empty()){
        int t=q.front();
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(dist[j]>dist[t]+1){
                dist[j]=dist[t]+1;
                cnt[j]=cnt[t];
                if(!st[j]){
                    st[j]=1;
                    q.push(j);
                }
            }
            else if(dist[j]==dist[t]+1)
            cnt[j]=(cnt[j]+cnt[t])%mod;
        }
     }
}
void solve(){
   memset(h,-1,sizeof h);
   int a,b;
   cin>>n>>m;
   while(m--){
    cin>>a>>b;
    add(a,b);
    add(b,a);//idx++会自动记录重边和自环
   }
   spfa();
   for(int i=1;i<=n;++i)cout<<cnt[i]<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```
### [P1608 路径统计 - 洛谷](https://www.luogu.com.cn/problem/P1608)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define ll long long
const int inf=0x3f3f3f3f,mod=100003;
const int N=2e3+5,M=N*N;
// int e[M],h[N],ne[M],st[N],dist[N],cnt[N],idx,n,m;
int g[N][N],st[N],dist[N],n,m,cnt[N];
// void add(int a,int b){
//     e[idx]=b;
//     ne[idx]=h[a];
//     h[a]=idx++;
// }
void Dijkstra(){
     memset(dist,inf,sizeof dist);
     dist[1]=0; cnt[1]=1;
    for(int i=1;i<=n;++i){
        int t=-1;
        for(int j=1;j<=n;++j)
            if(!st[j]&&(t==-1||dist[t]>dist[j]))t=j;
            st[t]=1;
        for(int j=1;j<=n;++j){
            if(dist[j]>dist[t]+g[t][j]){
                dist[j]=dist[t]+g[t][j];
                cnt[j]=cnt[t];
            }
            else if(dist[j]==dist[t]+g[t][j])
                cnt[j]+=cnt[t];
        }
    }
}
void solve(){
   //memset(h,-1,sizeof h);
   memset(g,inf,sizeof g);
   int a,b,c;
   cin>>n>>m;
   while(m--){
    cin>>a>>b>>c;
    g[a][b]=min(g[a][b],c);
   }
   Dijkstra();
   if(dist[n]==inf){cout<<"No answer\n";return;}
   else cout<<dist[n]<<" "<<cnt[n]<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```
