## [858. Prim算法求最小生成树 - AcWing](https://www.acwing.com/problem/content/860/)
##### 最小生成树是一个连通加权无向图中的一棵包含所有顶点的树，且所有边的权值之和最小
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
const int inf=0x3f3f3f3f;
const int N=5e2+10;
int g[N][N],st[N],dist[N],pri[N],n;
//生成树要找到每一个点对应的边，所以只用找到每一个集合外点到现生成树中的其中一个点的最短距离，加进去就行
int prim(){
    memset(dist,inf,sizeof dist);
    dist[1]=0; int res=0;
    for(int i=1;i<=n;++i){//遍历
        int t=-1;
        for(int j=1;j<=n;++j)//找最小
            if(!st[j]&&(t==-1||dist[j]<dist[t]))
             t=j; st[t]=1; res+=dist[t];
             if(dist[t]==inf){return inf;}
            for(int j=1;j<=n;++j){//更新
                if(!st[j]&&dist[j]>g[t][j]){
                dist[j]=g[t][j];
               // pri[j]=t;
            }
        }
    }
    return res;
}
// void getpath(){
//     for(int i=n;i>1;--i)
//     cout<<i<<" "<<pri[i]<<endl;//pri是i的前驱点
// }
void solve(){
    memset(g,inf,sizeof g);
    int m,a,b,c;
    cin>>n>>m;
    while(m--){
        cin>>a>>b>>c;
        g[a][b]=g[b][a]=min(g[a][b],c);
    }
    int f=prim();
    if(f==inf)cout<<"impossible\n";
    else cout<<f<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```

## [859. Kruskal算法求最小生成树 - AcWing](https://www.acwing.com/problem/content/861/)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
const int inf=0x3f3f3f3f;
const int N=1e5+10,M=2e5+7;
int p[N],n,m,res,cnt;
struct Edge{
    int a, b, w;
    bool operator<(const Edge&W)const{return w<W.w;}
}edge[M];
int find(int i){
    if(p[i]!=i)p[i]=find(p[i]);
    return p[i];
}
int kruskra(){
    for(int i=1;i<=m;++i){
        int pa=find(edge[i].a);
        int pb=find(edge[i].b);
        if(pa!=pb){
            res+=edge[i].w;
            p[pa]=pb;
            ++cnt;
        }
    }
}
void solve(){
    int a,b,c;
    cin>>n>>m;
    for(int i=1;i<=n;++i)p[i]=i;
    for(int i=1;i<=m;++i){
        cin>>a>>b>>c;
        edge[i]={a,b,c};
    }
    sort(edge+1,edge+1+m);
    kruskra();
    if(cnt<n-1)cout<<"impossible\n";
    else cout<<res<<endl;
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
    while(T--)solve();
    return 0;
}
```