##### 手写堆可支持的操作：
1. 插入一个数
2. 求集合当中的最小值
3. 删除最小值
4. *删出任意一个元素*
5. *修改任意一个元素*
6. 对应STL中的优先队列
 ![[Pasted image 20250720194326.png]]
###### 性质：
1. 从上往下依次增大，堆顶对应最小值
2. 储存方式：x节点的左子节点是2x, 右子节点是2x+1
3. 堆的性质是局部的：每个父节点比它的子节点大（最大堆）或小（最小堆），但不要求每一层的节点都比下一层的节点小或大。(堆的大小关系只涉及到父子节点，而不是兄弟节点之间的关系)
###### 操作：
## 🔁 上滤用循环的原因：
### 上滤路径是从节点到根（编号越来越小）
- 路径唯一：`i → parent(i) → parent(parent(i)) → ...`
- 最多走 log⁡n\log nlogn 步，走到根
- 易于写成 `while(i > 1)`
- 
### 示例代码：
```cpp
`void up(int i) {  
while(i > 1 && heap[i] < heap[i / 2]) {      
swap(heap[i], heap[i / 2]);   
i /= 2;  } 
}`
```
---
## 🔁 下滤常写成递归的原因：
### 下滤路径是从节点向两个子节点走（有分支）
- 每个点有两个子节点，要判断选哪个继续递归
- 写成递归会更自然清晰（结构类似 DFS）
### 示例代码（递归）：
```cpp
void down(int i) {  
int t = i;  
if(2 * i <= size && heap[2 * i] < heap[t]) t = 2 * i;   
if(2 * i + 1 <= size && heap[2 * i + 1] < heap[t]) t = 2 * i + 1;   
if(t != i) {     
swap(heap[i], heap[t]);    
down(t); // 递归继续往下   
    }
}`
```
# [838. 堆排序 - AcWing题库](https://www.acwing.com/problem/content/840/)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
//#define ll long long
//#define ULL unsigned long long
//const int N=1e5+3,P=131;
const int N=1e5+10;
int n,m;
int h[N],ph[N],hp[N],cnt;
void down(int u){
    int t=u;
    if(u*2<=cnt&&h[u*2]<h[t])t=u*2;
    if(u*2+1<=cnt&&h[u*2+1]<h[t])t=u*2+1;
    if(u!=t){
        swap(h[u],h[t]);
        down(t);
    }
}
void solve(){
  int n,m; cin>>n>>m;
  for(int i=1;i<=n;++i)cin>>h[i];
  cnt=n;                    
  for(int i=n/2;i;--i)down(i);
  //堆化,初始化堆(小顶堆)的结构
  //从n/2开始堆化,是因为从n/2+1到n的节点是叶节点，它们不需要调整。n/2是最大的有子节点的父节点
  //父节点的序号是子节点的1/2
  while(m--){
    cout<<h[1]<<" \n"[m==0];
    h[1]=h[cnt];
    --cnt;
    down(1);
  }
 
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
   while(T--)solve();
   return 0;
}
```

# [839. 模拟堆 - AcWing题库](https://www.acwing.com/problem/content/submission/841/)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
//#define ll long long
//#define ULL unsigned long long
//const int N=1e5+3,P=131;
const int N=1e5+10;
int n,m;
int h[N],ph[N],hp[N],cnt;
//ph:记录第几个插入； hp:如果堆中第i个插入的元素在堆数组 h 中的位置
void heap_swap(int a,int b){
    swap(ph[hp[a]],ph[hp[b]]);
    swap(hp[a],hp[b]);
    swap(h[a],h[b]);
   //更新两个元素的编号映射（`ph[编号] = 新位置`）  
  //更新两个位置对应的编号（`hp[位置] = 新编号`）
  //交换堆的值
  //hp的存在可以维持ph的正确性，顺序不要颠倒
}
void down(int u){
    int t=u;
    if(u*2<=cnt&&h[u*2]<h[t])t=u*2;
    if(u*2+1<=cnt&&h[u*2+1]<h[t])t=u*2+1;
    if(u!=t){
        heap_swap(u,t);
        down(t);
    }
}
void up(int u){
    while(u/2&&h[u/2]>h[u]){
        heap_swap(u/2,u);
        u/=2;
    }
}
void solve(){
  int n,m=0; cin>>n;
  while(n--){
    string op;
    int k,x;
    cin>>op;
    //cout<<op<<endl;
    if(op=="I"){
        cin>>x;
        ++cnt; ++m;
        ph[m]=cnt,hp[cnt]=m;
        //在m编号所在的位置cnt；第cnt位置对应的编号m  
        h[cnt]=x;
        up(cnt);//将下表上浮
    }
    else if(op=="PM")cout<<h[1]<<endl; 
    else if(op=="DM"){
        heap_swap(1,cnt);
        --cnt;
        down(1);
    } 
    else if(op=="D"){
        cin>>k;
        k=ph[k];
        heap_swap(k,cnt);
        --cnt;
        down(k),up(k);//不知道交换之后堆中的大小关系
    }
    else{
        cin>>k>>x;
        k=ph[k];
        h[k]=x;
        down(k),up(k);
    }
  }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
   while(T--)solve();
   return 0;
}

```
![[11d367ed32b82b31894ec65e8098fdc.png]]
