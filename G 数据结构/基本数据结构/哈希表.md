### 作用：可用较小的空间来储存较大的值同时还能避免储存冲突
### 存值方法：
1. 拉链法：利用模(一般是1e5+3)和链表储存
2. 开放寻址法：类似厕所找坑（有人的话就到另一个坑位去看看）


###  哈希字符串：
### 作用：快速判断两个(区间)字符串是否相等O(1)
将每个字符串中的字符转成P进制在模上Q;
*一般P取131或13331，Q取2^64 或直接用（unsigned long long）*
```cpp
[l, r]=h[r]-h[l]*p^(k-l+1)
因为把l直接移动到高位它后面（[r-l+1]）原来是没有数的，但是r有,所以直接用r减去它即可等得到
相当于百位减去百位即可得到十位区间
求 h[s[2, 3]]
h[3] = h['abc'] = h['a'] * pow(P, 2) + h['b'] * pow(P, 1) + h['c'] = 1,677,554
h[1] = h['a'] = 97
h[s[2, 3]] = h['bc'] = h['b'] * pow(P, 1) + h['c']
所以：h[s[2, 3]]= h[3] - h[1] * pow(P, 2) = 12,937‬
也就是：h[s[l, r]] = h[r] - h[l - 1] * pow(P, r - l + 1)
```
# [840. 模拟散列表 - AcWing题库](https://www.acwing.com/problem/content/842/)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
//#define ll long long
const int N=1e5+3;
int h[N],e[N],ne[N],idx;
void insert(int x){
    int k=(x%N+N)%N;
    e[idx]=x;
    ne[idx]=h[k];
    h[k]=idx++;
}
bool find(int x){
    int k=(x%N+N)%N;
    for(int i=h[k];i!=-1;i=ne[i])
    if(e[i]==x)return true;
    return false;
}
void solve(){
   int n; cin>>n;
   memset(h,-1,sizeof h);
   while(n--){
    string op;
    int x;
    cin>>op>>x;
    if(op=="I")insert(x);
    else{
        if(find(x))cout<<"Yes\n";
        else cout<<"No\n";
    }
   }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
   while(T--)solve();
   return 0;
}
```

# [841. 字符串哈希 - AcWing题库](https://www.acwing.com/problem/content/843/)
```cpp
#include<bits/stdc++.h>
using namespace std;
#define endl "\n"
//#define int long long
//#define ll long long
#define ULL unsigned long long
const int N=1e5+3,P=131;
int n,m;
string str;
ULL h[N],p[N];
ULL get(int l,int r){
    return h[r]-h[l-1]*p[r-l+1];
}
void solve(){
   cin>>n>>m>>str;
   str=' '+str;
   p[0]=1;
   for(int i=1;i<=n;++i){
    p[i]=p[i-1]*P;
    h[i]=h[i-1]*P+str[i];
   }
   while(m--){
    int l1,r1,l2,r2;
    cin>>l1>>r1>>l2>>r2;
    if(get(l1,r1)==get(l2,r2))cout<<"Yes\n";
    else cout<<"No\n";
   }
}
signed main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T=1;
    //cin>>T;
   while(T--)solve();
   return 0;
}
```