# [P5094 [USACO04OPEN] MooFest G 加强版 - 洛谷](https://www.luogu.com.cn/problem/P5094)

- **`tr1`（用于记录奶牛数量）**：
    - `tr1` 主要用来存储每个坐标位置 `x` 上有多少只奶牛（数量）。它是一个标准的 **二叉索引树**（或树状数组），用于对奶牛的数量进行累积和查询。
    - `tr1.add(x, 1)` 操作会将坐标为 `x` 的奶牛的数量增加 1。
    - `tr1.sum(x)` 用来查询坐标小于等于 `x` 的奶牛数量的累积和。具体来说，`sum(x)` 返回的是所有坐标 `<= x` 的奶牛的数量。
- **`tr2`（用于记录奶牛坐标的累积和）**：
    - `tr2` 用来存储奶牛坐标的累积和。它用于记录到当前坐标 `x` 为止的所有奶牛坐标的总和。
    - `tr2.add(x, x)` 操作会将坐标为 `x` 的奶牛的坐标加入到累积和中。
    - `tr2.sum(x)` 用来查询坐标小于等于 `x` 的所有奶牛的坐标和，`sum(x)` 返回的是坐标 `<= x` 的奶牛坐标的累积和。
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
#define pii pair<int, int>
#define lowbit(x) ((x) & (-x))
const int N = 5e4 + 10;
//相当于对于xj前面的每个xi分别求左边和右边到xj的距离和
struct BIT{//树状数组封装模板
    int n; vi tr;
    BIT(int n1 = 0){init(n1);}//初始化函数
    void init(int n1){
        n = n1;
        tr.assign(n + 1, 0);//初始化，清空tr数组
    }
    void add(int x, int k){//插入
        for(int i = x; i <= n; i += lowbit(i)) tr[i] += k;
    }
    int sum(int x){//求前缀和
        int ans = 0;
        for(int i = x; i; i -= lowbit(i)) ans += tr[i];
        return ans;
    }
    // int sum(int l, int r){//区间和查询
    //     return sum(r) - sum(l - 1);
    //}
//     int get(int i) {//在树状数组（BIT）中获取第 i 项的原始值 a[i]
//     int res = tr[i];
//     int z = i - lowbit(i);
//     i--;
//     while (i != z) {
//         res -= tr[i];
//         i -= lowbit(i);
//     }
//     return res;
//     //return tr[i];
// }
}tr1, tr2;

void solve(){
    int n; cin >> n;
    tr1.init(N), tr2.init(N);
    vector<pii> all(n);
    for(auto &i : all) cin >> i.first >> i.second;
    sort(all.begin(), all.end());
    int ans = 0, cnt_all = 0, sum_all = 0;
    for(auto &[v, x] : all){
        int cnt_l = tr1.sum(x - 1), cnt_r = cnt_all - cnt_l;
        int sum_l = tr2.sum(x - 1), sum_r = sum_all - sum_l;
        ans += (cnt_l * x - sum_l + sum_r - cnt_r * x) * v;
        //左边每个左边的所有奶牛*当前距离-所在区间的左缀和+所在区间的右缀和-左边每个右边的所有奶牛*当前距离
        tr1.add(x, 1), tr2.add(x, x);
        //只要你没有显式重新定义或清空，一个对象的数据（比如类中的数组）每次调用是“持续累积的”，不会被自动重置。
        cnt_all++, sum_all += x;
    }
    cout << ans << endl;
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    //cin >> T;
    while(T--) solve();
    return 0;
}
```