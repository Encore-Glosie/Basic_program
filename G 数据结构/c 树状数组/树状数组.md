![[Pasted image 20250716111556.png]]

# https://oi-wiki.org/ds/fenwick/

树状数组（Fenwick Tree）是一种高效的数据结构，专门用于解决**动态前缀和查询**和**单点更新**问题。它的核心优势是用简洁的实现和较低的空间复杂度
## 将更新和查询操作的时间复杂度均降至 O(log n)。
### 一、核心原理
树状数组通过二进制的特性（低位有效位）建立数组元素之间的关联，形成一个类似树形的结构。每个节点 `tree[i]` 并非只存储单个元素的值，而是存储**某段连续元素的和**，其覆盖范围由 `i` 的二进制最低位的 1 决定（即 `lowbit(i)`）。表示的是区间和。
#### 关键函数：`lowbit(x)`
```cpp
*#define lowbit(x) ((x) & (-x))
```
- 功能：返回 `x` 的二进制表示中**最低位的 1 所对应的值**（例如：`lowbit(6) = 2`，因为 6 的二进制是 `110`，最低位 1 对应的值为 2）。
- 作用：确定树状数组中节点的覆盖范围和父子关系。
### 二、核心操作
树状数组的两大核心操作是**单点更新**和**前缀和查询**，以下是基于 1-based 索引（数组下标从 1 开始）的实现：
#### 1. 单点更新（`add`）
向索引 `i` 的位置增加一个值 `k`：
```cpp
void add(int idx, int k) {
     for(int i=idx;i<=n;i+=lowbit(i)) tree[i] += k;
}
	   // 从 i 开始，向上更新所有父节点
      // 移动到父节点（通过 lowbit 找到下一个需要更新的节点）
     // 更新当前节点
```
- 时间复杂度：O(\log n)，因为每次循环 `i` 至少增加 1 个二进制位，最多循环 (log n) 次。
#### 2. 前缀和查询（`sum`）
查询从索引 `1` 到 `i` 的前缀和：
```cpp
int sum(int idx) {
    int ans = 0;
    for(int i=idx;i;i-=lowbit(i)) ans += tree[i]; 
	return res; 
}
	  // 从 idx 开始，向下累加所有子节点
     // 累加当前节点的值
    // 移动到子节点（通过 lowbit 找到下一个需要累加的节点）
```
- 时间复杂度：\(O(\log n)\)，同理最多循环 \(\log_2 n\) 次。
#### 3. 区间查询（`rangeSum`）
查询索引 `[l, r]` 的区间和（基于前缀和推导）：
```cpp
int rangeSum(int l, int r) {
    return sum(r) - sum(l - 1);
}
```
- 时间复杂度：\(O(\log n)\)，相当于两次前缀和查询。

# [L-Numb Numbers_2025牛客暑期多校训练营1](https://ac.nowcoder.com/acm/contest/108298/L)
```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl '\n'
#define int long long
#define vi vector<int>
#define pii pair<int, int>
#define arr3 array<int, 3>
#define lowbit(x) ((x) & (-x))
const int N = 2e5 + 10, M = 1e6 + 10, inf = 0x3f3f3f3f, Inf = INT_MAX, mod = 1e9 + 7;
int a[N], tr[N << 1];
vi all;
pii cntq[N];

void add(int x, int k){
    for(int i = x; i <= all.size(); i += lowbit(i)) tr[i] += k;
}
int sum(int x){
    int ans = 0;
    for(int i = x; i; i -= lowbit(i)) ans += tr[i];
    return ans;
}
int bs(int k){
    int pos = 0;
    int maxn = 1 << 20;
    for(int d = maxn; d > 0; d >>= 1){
        if(pos + d <= all.size() && tr[pos + d] <= k){
            pos += d;
            k -= tr[pos];
        }
    }
    return pos;
}

void solve(){
    int n, q; cin >> n >> q;
    int top = n-(n/2);
    all.clear();
    for(int i = 1; i <= n; i++) cin >> a[i], all.emplace_back(a[i]);
    for(int i = 1; i <= q; i++){
        cin >> cntq[i].first >> cntq[i].second;
        a[cntq[i].first] += cntq[i].second;
        all.emplace_back(a[cntq[i].first]);
    }
    for(int i = 1; i <= q; i++) a[cntq[i].first] -= cntq[i].second;
    sort(all.begin(), all.end());//排序
    all.erase((unique(all.begin(), all.end())), all.end());//去重
    int m = all.size();
    fill(tr + 1, tr + m + 1, 0);
    for(int i = 1; i <= n; i++){
        int idx = lower_bound(all.begin(), all.end(), a[i]) - all.begin() + 1;
        add(idx, 1);
    }
    for(int i = 1; i <= q; i++){
        int p = cntq[i].first, v = cntq[i].second;
        int idx = lower_bound(all.begin(), all.end(), a[p]) - all.begin() + 1;
        add(idx, -1);
        a[p] += v;
        idx = lower_bound(all.begin(), all.end(), a[p]) - all.begin() + 1;
        add(idx, 1);
        cout << sum(bs(top)) << endl;
    }
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```

# [1006 半杭电](https://acm.hdu.edu.cn/contest/problem?cid=1173&pid=1006)
#### 最少禁赛数 = (第一场比他强的) + (第二场比他强的) - (两场都比他强的)
#### 每组时间复杂度O(nlogn)

```cpp
#include <bits/stdc++.h>
using namespace std;
#define endl "\n"
#define int long long
#define lowbit(x) ((x)&(-x))
struct BIT{
    int n; vector<int>tr;
    BIT(int n1 = 0){init(n1);}//初始化
    void init(int n1){
        n = n1;
        tr.assign(n+1,0);
    }
    void add(int x, int k){
        for(int i=x;i<=n; i+=lowbit(i)) tr[i]+=k;
    }
    int sum(int x){
        int ans=0;
        for(int i=x;i;i-=lowbit(i)) ans+=tr[i];
        return ans;
    }
    // int sum(int l, int r){
    //     return sum(r) - sum(l - 1);
    // }
    // int get(int i){
    //     return tr[i];
    // }
}tri;

void solve(){
    int n; cin>>n;  tri.init(n);
    vector<int>a(n+1),b(n+1),id(n+1),ans(n+1);
    for(int i=1;i<=n;++i) cin>>a[i];
    for(int i=1;i<=n;++i) cin>>b[i],id[b[i]]=i;
   //id用来存b的排名
    for(int i=1;i<=n;++i){
        int t=a[i];
        ans[t]=(i-1)+(id[t]-1)-tri.sum(id[t]-1);
        tri.add(id[t],1);
    }
    //tri,add(id[t],1);在处理a的选手中的过程中把出现在b中的排名放入tri中
    //tri.sum(id[t]-1);由此就可以找被a处理过且排名出现在b的前面的人数
    for(int i=1;i<=n;++i) cout<<ans[i]<<" \n"[i==n];
}

signed main(){
    ios::sync_with_stdio(0), cin.tie(0), cout.tie(0);
    int T = 1;
    cin >> T;
    while(T--) solve();
    return 0;
}
```
