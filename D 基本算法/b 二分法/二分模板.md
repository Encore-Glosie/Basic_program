
二分模板一共有两个，分别适用于不同情况。
算法思路：假设目标值在闭区间[l, r]中， 每次将区间长度缩小一半，当l = r时，我们就找到了目标值。
版本1
当我们将区间[l, r]划分成[l, mid]和[mid + 1, r]时，其更新操作是r = mid或者l = mid + 1;，计算mid时不需要加1。
```cpp
C++ 代码模板：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```
版本2
当我们将区间[l, r]划分成[l, mid - 1]和[mid, r]时，其更新操作是r = mid - 1或者l = mid;，此时为了防止死循环，计算mid时需要加1。
```cpp
C++ 代码模板：
int bsearch_2(int l, int r)
{
    while (l < r)
    {  //当r=l-1时，mid=l (int的向下取整) if(check(mid))会陷入死循环
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
#### 二分搜索
## [P1926 - 等值区间 Ⅱ - ZJHUOJ](http://172.20.8.83/problem.php?id=1926)
```cpp
/*
分析：    
    搜索 a[i] >= x 的下界
    搜索 a[i] >= x+1 的下界
*/
#include<bits/stdc++.h>
using namespace std;
const int mxn = 1e5+5;
int n, q, a[mxn];
bool check(int p, int val){
    return a[p] >= val;
}
int b_s(int val){
    int low = n+1; // 初始值，表示下界不存在
    int l = 0, r = n, mid; // 左开右闭
    while(l < r){
        mid = l+r+1>>1;
        if(check(mid, val)) low = mid, r = mid-1;
        else l = mid;
    }
    return low;
}
int main(){
    scanf("%d%d", &n, &q);
    for(int i = 1; i <= n; ++i) scanf("%d", a+i);
    int x;
    while(q--){
        scanf("%d", &x);
        printf("%d %d\n", b_s(x), b_s(x+1));
    }
    return 0;
}
stl:
#include<bits/stdc++.h>
using namespace std;
const int mxn=1e5+5;
int a[mxn],n,q,m;
signed main(){
    scanf("%d%d",&n,&q);
   for(int i=1;i<=n;++i)scanf("%d",a+i);
    while(q--){
        scanf("%d",&m);
        printf("%d %d\n",lower_bound(a+1,a+n+1,m)-a,upper_bound(a+1,a+n+1,m)-a);
    }
   return 0;
}
```
==lower_bound是找到第一个大于等于；而upper_bound是找到第一个大于==